) SOMA Standard Library
) Derived operations built from FFI primitives

) ==================== Coding Principles ====================
)
) These principles apply specifically to stdlib code, where robustness
) and composability are critical.
)
) 1. NO TEMP NAMESPACE FOR PERSISTENT STATE
)    Never store state in the temp namespace that must survive nested calls.
)    If a function's folder/callback might call the same function recursively,
)    the temp storage will be clobbered. Instead, pass state through the
)    iteration using context-passing (include it in the AL for each iteration).
)
)    BAD:  _.folder !temp.fold_fn ... temp.fold_fn >^
)    GOOD: Pass folder through: _.folder _.acc _.list then pop !_.list !_.acc !_.folder
)
) 2. PRIVATE HELPER NAMING: x.#y
)    Internal helper blocks local to a package use the # prefix convention.
)    This signals "private/internal" and avoids polluting the public namespace.
)
)    Example: list.fold.#loop, dict.put.#update, dict.put.#prepend
)
) 3. CONTEXT-PASSING FOR CHOOSE BRANCHES
)    Blocks inside choose branches cannot access the outer Register directly.
)    Push the context reference before choose, then pop it inside each branch:
)
)    _.                    ) Push context reference
)    <condition>
)    { !_. _.outer_var ... } ) Pop context, access outer variables
)    { !_. _.other_var ... }
)    >choose >^
)
) 4. DOCUMENT AL SIGNATURES
)    Every public function must document its stack effect:
)    ) AL: [arg1, arg2, container, ...] -> [result, ...]
)    Remember: rightmost = top of stack (pushed last, popped first)
)
) 5. FUNCTIONAL/IMMUTABLE STYLE
)    Mutating operations return new containers rather than modifying in place.
)    This matches SOMA's functional nature and enables safe composition.
)
)    Example: dict.put returns a new dict, original is unchanged
)
) 6. CHAIN PATTERN FOR ITERATION
)    Use >chain with Nil-terminated loops for iteration. The loop block
)    returns either [result, Nil] to stop or [state..., loop] to continue.
)    This avoids deep recursion and enables clean iterative patterns.
)
) ==============================================================

) ==================== Boolean Logic ====================

) not: Boolean negation
{False True >choose} !not

) and: Logical AND
{False >choose} !and

) or: Logical OR
{True >swap >choose} !or

) ==================== Comparison Operators ====================

) Greater-than: execute as >>
{>swap ><} !>

) Not equal: execute as >=!
{>over >over >swap >< >rot >rot >< >or} !=!

) Equality: execute as >==
{>=! >not} !==

) Less-than-or-equal: execute as >=<
{>swap >< >not} !=<

) Greater-than-or-equal: execute as >=>
{>< >not} !=>

) ==================== Stack Manipulation ====================

) dup: Duplicate top
{!_.value _.value _.value} !dup

) drop: Remove top
{!_} !drop

) swap: Swap top two
{!_.a !_.b _.a _.b} !swap

) over: Copy second to top
{!_.a !_.b _.b _.a _.b} !over

) rot: Rotate top three
{!_.a !_.b !_.c _.b _.a _.c} !rot

) ==================== Arithmetic Helpers ====================

) inc: Increment by 1
{1 >+} !inc

) dec: Decrement by 1
{1 >-} !dec

) abs: Absolute value
{>dup 0 >< {0 >swap >-} {} >choose >^} !abs

) min: Minimum of two values
{>over >over >< {>drop} {>swap >drop} >choose >^} !min

) max: Maximum of two values
{>over >over >> {>drop} {>swap >drop} >choose >^} !max

) ==================== Control Flow Helpers ====================

) times: Execute block N times
) AL: [n, block, ...] -> [...]
) Usage: 10 { (Hello) >print } >times
{
  {
    !_.user_blk !_.cnt
    >_.user_blk
    _.cnt 1 >-
    !_.new_cnt
    _.new_cnt _.user_blk
    >block
    0 _.new_cnt ><
    {}
    {>drop >drop >drop Nil}
    >choose >^
  } >chain
  >drop
} !times

) if: Execute block if condition is true
) AL: [condition, block, ...] -> [...]
) Usage: True { (Hello) >print } >if
{{} >choose >^} !if

) ifelse: Conditional with both branches (alias for choose)
) AL: [condition, true_block, false_block, ...] -> [...]
) Usage: x 0 >< { (positive) } { (not positive) } >ifelse
{>choose >^} !ifelse

) ^: Execute from AL (like Forth's EXECUTE)
) AL: [block, ...] -> [result, ...]
{ !_ >_ } !^

) while: Loop while condition is true
) AL: [cond_block, body_block, ...] -> [...]
) Usage: { count 10 >< } { count >print count >inc } >while
{
  {
    !_.body !_.cond
    _.cond _.body                 ) Push state back onto AL
    >block                        ) Push loop block
    >_.cond                       ) Execute condition LAST so bool is on top
    {
      !_.loop !_.body !_.cond     ) Pop state from AL (choose already popped)
      >_.body                     ) Execute body
      _.cond _.body _.loop        ) Push state back for next iteration
    }
    {>drop >drop >drop Nil}       ) False: cleanup
    >choose >^
  } >chain
  >drop
} !while

) do: Execute body first, then loop while condition is true
) AL: [body_block, cond_block, ...] -> [...]
) Usage: { count >print count >inc } { count 10 >< } >do
{
  {
    !_.cond !_.body
    >_.body                       ) Execute body first
    _.body _.cond                 ) Push state back onto AL
    >block                        ) Push loop block
    >_.cond                       ) Execute condition LAST so bool is on top
    {}                            ) True: empty (state already on AL)
    {>drop >drop >drop Nil}       ) False: cleanup
    >choose >^
  } >chain
  >drop
} !do

) ==================== Linked List Operations ====================
) Linked lists using CellRefs and context-passing style
) Empty list is Nil, nodes have .value and .next

) list.new: Create empty list
) AL: [...] -> [Nil, ...]
{
  Nil
} !list.new

) list.cons: Prepend value to list (functional cons)
) AL: [value, list, ...] -> [new_node, ...]
) Creates new node with value, next points to list
) Pure CellRef implementation - node lives in this block's Register
{
  !_.list !_.value  ) Pop list first (top), then value
  _.value !_.node.value
  _.list !_.node.next
  _.node.  ) Return CellRef to the node (persists after block!)
} !list.cons

) ==================== AL Draining Operations ====================

) al.drain: Drain AL until Void, applying action to each item
) AL: [void, item1, item2, ..., itemN, persistent, action_block, ...] -> [...]
) The action_block receives: [current, persistent, ...] on AL
) Core state transformer: AL -> AL'
{
  {
    !_.todo !_.persistent !_.current    ) Pop action, persistent, current

    ) Put context on AL for choose blocks
    _.
    _.current >isVoid                   ) Check: AL=[bool, CTX, ...rest]
    {
      ) Void - cleanup and stop
      !_.                               ) Pop context
      _.persistent                      ) Leave persistent on AL
      Nil                               ) Stop chain
    }
    {
      ) Not void - process and continue
      !_.                               ) Pop context
      _.current _.persistent _.todo >^  ) Execute action: AL=[persistent, current, ...]
      _.todo                            ) Just push todo (new_persistent already on AL)
      al.drain.#loop                    ) AL=[loop, todo, new_persistent, ...rest]
    }
    >choose
  } !al.drain.#loop

  al.drain.#loop >^
  >chain
  >drop
} !al.drain

) ==================== List Transformations ====================

) list.from_al: Drain AL into linked list
) AL: [void, items..., ...] -> [list, ...]
) Uses al.drain with list.cons to build list from AL items
) Preserves AL order: Void (a) (b) (c) -> list (a,b,c)
{
  >list.new { !_.persistent !_.current _.current _.persistent >list.cons } >al.drain
} !list.from_al

) list.to_al: Push list items onto AL
) AL: [list, ...] -> [items..., ...]
) Traverses list, pushes each .value onto AL
) Preserves order: list (a,b,c) -> AL: [(a), (b), (c)]
{
  {
    !_.list                       ) Pop list node from AL
    _.list                        ) Save for isNil check
    _.list >isNil                 ) Check if Nil: AL=[bool, list_node]
    {
      ) True branch: list is Nil
      !_.                         ) Pop the list_node
      Nil                         ) Return Nil to stop chain
    }
    {
      ) False branch: list is not Nil
      !_.node                      ) Pop and save the list_node
      _.node.value                ) Get value and push to AL
      _.node.next                 ) Get next node and push to AL
      list.to_al.#loop            ) Push loop block for next iteration
    }
    >choose
  } !list.to_al.#loop

  list.to_al.#loop
  >chain
  >drop
} !list.to_al

) list.reverse: Reverse a list by copying
) AL: [list, ...] -> [reversed_list, ...]
) Traverses original, conses onto new list
) Reverses order: (a,b,c) -> (c,b,a)
) Uses context-passing: each iteration receives [old_list, new_list, ...] on AL
{
  {
    !_.old_list !_.new_list       ) Pop in LIFO order: top is old_list (pushed second), next is new_list (pushed first)
    _.                            ) Push Register context onto AL for choose branches
    _.old_list >isNil             ) Check: AL=[bool, CTX, ...]
    {
      !_.                         ) Pop Register context from previous block
      ) Nil - return accumulated list
      _.new_list                  ) Return result
      Nil                         ) Stop chain
    }
    {
      !_.                         ) Pop Register context from previous block
      ) Not Nil - cons and continue
      _.old_list.value _.new_list >list.cons  ) Create new_list with value consed
      !_.new_new_list                         ) Save it
      _.new_new_list _.old_list.next          ) Push for next iteration in correct order: new_list first, old_list second
      list.reverse.#loop                      ) Push loop block from Store
    }
    >choose
  } !list.reverse.#loop

  Nil >swap                       ) AL=[original_list, Nil, ...] → swap → AL=[Nil, original_list, ...]
  list.reverse.#loop                ) Initial push from Store
  >chain
  >drop
} !list.reverse

) list.map: Apply transform to each element
) AL: [transform_block, list, ...] -> [mapped_list, ...]
) Converts list to AL, applies transform to each item, builds new list
) Order is preserved: al.drain processes in LIFO order, cons prepends,
) so the two reversals cancel out and we get the original order.
{
  !_.transform !_.list              ) Pop in LIFO: transform (top), then list
  _.transform !temp.map_transform   ) Store transform temporarily in Store
  Void                              ) Push Void marker first
  _.list >list.to_al                ) Convert list to AL: AL=[Void, items..., ...]
  Nil                                ) Initial accumulator (empty list)
  {
    !_.persistent !_.current         ) Pop current item and accumulated list
    _.current temp.map_transform >^  ) Apply transform using Store path
    _.persistent >list.cons          ) Cons onto list: AL=[new_list, ...]
  }
  >al.drain                          ) Build list (order preserved by double-reversal)
} !list.map

) list.length: Count elements in list
) AL: [list, ...] -> [count, ...]
) Traverses list, counting nodes until Nil
{
  {
    !_.list !_.count                  ) Pop list (top) and count
    _.                                ) Push context for choose
    _.list >isNil                     ) Check if Nil
    {
      !_.                             ) Pop context
      _.count                         ) Return count
      Nil                             ) Stop chain
    }
    {
      !_.                             ) Pop context
      _.count 1 >+                    ) Increment count
      _.list.next                     ) Get next node
      list.length.#loop               ) Continue
    }
    >choose >^
  } !list.length.#loop

  0 >swap                             ) AL=[0, list, ...]
  list.length.#loop
  >chain
  >drop
} !list.length

) list.fold: Reduce list with accumulator
) AL: [folder, init, list, ...] -> [result, ...]
) folder receives [current, acc, ...] and returns new acc
) Processes from head to tail (left fold)
{
  !_.list !_.init !_.folder           ) Pop: list (top), init, folder

  {
    !_.list !_.acc !_.folder          ) Pop list (top), acc, folder
    _.                                ) Push context for choose
    _.list >isNil                     ) Check if Nil
    {
      !_.                             ) Pop context
      _.acc                           ) Return accumulator
      Nil                             ) Stop chain
    }
    {
      !_.                             ) Pop context
      _.acc _.list.value _.folder >^  ) Apply folder: [current, acc] -> new_acc
      !_.new_acc                      ) Save new accumulator
      _.folder _.new_acc _.list.next  ) Push [folder, new_acc, next] for iteration
      list.fold.#loop                 ) Continue
    }
    >choose >^
  } !list.fold.#loop

  _.folder _.init _.list              ) Push [folder, init, list]
  list.fold.#loop
  >chain
  >drop
} !list.fold

) list.append: Concatenate two lists
) AL: [list1, list2, ...] -> [concatenated, ...]
) Result has list1 elements followed by list2 elements
{
  !_.list2 !_.list1                   ) Pop list2 (top), list1
  _.list1 >list.reverse               ) Reverse list1
  !_.reversed

  {
    !_.list !_.acc                    ) Pop reversed (top) and accumulator (list2)
    _.                                ) Push context for choose
    _.list >isNil                     ) Check if Nil
    {
      !_.                             ) Pop context
      _.acc                           ) Return result
      Nil                             ) Stop chain
    }
    {
      !_.                             ) Pop context
      _.list.value _.acc >list.cons   ) Cons value onto accumulator
      !_.new_acc
      _.new_acc _.list.next           ) Push [new_acc, next]
      list.append.#loop               ) Continue
    }
    >choose >^
  } !list.append.#loop

  _.list2 _.reversed                  ) Push [list2, reversed]
  list.append.#loop
  >chain
  >drop
} !list.append

) list.filter: Keep elements matching predicate
) AL: [predicate, list, ...] -> [filtered, ...]
) predicate receives [value, ...] and returns bool
) Order is preserved (same trick as list.map)
{
  !_.list !_.predicate                ) Pop list (top), predicate
  _.predicate !temp.filter_pred       ) Store predicate in temp
  Void                                ) Push Void marker
  _.list >list.to_al                  ) Convert to AL: [Void, items...]
  Nil                                 ) Initial accumulator (empty list)
  {
    !_.acc !_.current                 ) Pop accumulator (top), current
    _.current temp.filter_pred >^     ) Apply predicate
    !_.keep                           ) Save result
    _.                                ) Push context for choose
    _.keep                            ) Push bool for choose
    {
      !_.                             ) Pop context
      _.current _.acc >list.cons      ) Keep: cons onto accumulator
    }
    {
      !_.                             ) Pop context
      _.acc                           ) Discard: return accumulator unchanged
    }
    >choose >^                        ) Execute chosen branch
  }
  >al.drain                           ) Build filtered list
} !list.filter

) ==================== Debug Utilities ====================

) debug.assert: Assert a condition, halt if false
) AL: [condition_block, message, ...] -> [...] or HALT
) Executes condition_block; if result is False, halts with message
) Usage: { x 0 >> } (x must be positive) >debug.assert
{
  !_.msg !_.cond
  _.                                   ) Push context for choose branches
  >_.cond                              ) Execute condition block
  {
    !_.                                ) Pop context (True branch - discard)
  }
  {
    !_.                                ) Pop context
    _.msg >debug.error                 ) Halt with error message
  }
  >choose >^
} !debug.assert

) ==================== Dictionary (Red-Black Tree) ====================
) Key-value dictionary implemented as a red-black tree
) Structure: Nil | node where node.key, node.value, node.color, node.left, node.right
) Color: True = red, False = black
) Supports any key type that works with >< and >==
)
) Red-Black Tree Invariants:
) 1. Root is always black
) 2. No red node has a red child
) 3. All paths from root to leaves have the same black count
) 4. BST property: left.key < node.key < right.key

) dict.new: Create empty dictionary
) AL: [...] -> [dict, ...]
{
  Nil
} !dict.new

) dict.has: Check if key exists
) AL: [key, dict, ...] -> [bool, ...]
{
  !_.dict !_.key

  {
    !_.node !_.key
    _.                                   ) Push context for choose
    _.node >isNil
    {
      !_.                                ) Pop context
      False                              ) Key not found
      Nil                                ) Stop chain
    }
    {
      !_.                                ) Pop context
      _.                                 ) Push context for inner choose
      _.node.key _.key >==
      {
        !_.                              ) Pop context
        True                             ) Key found
        Nil                              ) Stop chain
      }
      {
        !_.                              ) Pop context
        ) BST: go left if key < node.key, right otherwise
        _.
        _.key _.node.key ><              ) key < node.key
        {
          !_.
          _.key _.node.left              ) Search left subtree
        }
        {
          !_.
          _.key _.node.right             ) Search right subtree
        }
        >choose >^
        dict.has.#loop
      }
      >choose >^
    }
    >choose >^
  } !dict.has.#loop

  _.key _.dict
  dict.has.#loop
  >chain
  >drop
} !dict.has

) dict.get: Get value by key (errors if not found)
) AL: [key, dict, ...] -> [value, ...]
{
  !_.dict !_.key

  {
    !_.node !_.key
    _.                                   ) Push context for choose
    _.node >isNil
    {
      !_.                                ) Pop context
      Nil.value                          ) Key not found - error via Nil dereference
    }
    {
      !_.                                ) Pop context
      _.                                 ) Push context for inner choose
      _.node.key _.key >==
      {
        !_.                              ) Pop context
        _.node.value                     ) Return value
        Nil                              ) Stop chain
      }
      {
        !_.                              ) Pop context
        ) BST: go left if key < node.key, right otherwise
        _.
        _.key _.node.key ><              ) key < node.key
        {
          !_.
          _.key _.node.left              ) Search left subtree
        }
        {
          !_.
          _.key _.node.right             ) Search right subtree
        }
        >choose >^
        dict.get.#loop
      }
      >choose >^
    }
    >choose >^
  } !dict.get.#loop

  _.key _.dict
  dict.get.#loop
  >chain
  >drop
} !dict.get

) dict.get_or: Get value by key, or return default if not found
) AL: [key, default, dict, ...] -> [value, ...]
{
  !_.dict !_.default !_.key

  {
    !_.node !_.key !_.default
    _.                                   ) Push context for choose
    _.node >isNil
    {
      !_.                                ) Pop context
      _.default                          ) Return default
      Nil                                ) Stop chain
    }
    {
      !_.                                ) Pop context
      _.                                 ) Push context for inner choose
      _.node.key _.key >==
      {
        !_.                              ) Pop context
        _.node.value                     ) Return value
        Nil                              ) Stop chain
      }
      {
        !_.                              ) Pop context
        ) BST: go left if key < node.key, right otherwise
        _.
        _.key _.node.key ><              ) key < node.key
        {
          !_.
          _.default _.key _.node.left    ) Search left subtree
        }
        {
          !_.
          _.default _.key _.node.right   ) Search right subtree
        }
        >choose >^
        dict.get_or.#loop
      }
      >choose >^
    }
    >choose >^
  } !dict.get_or.#loop

  _.default _.key _.dict
  dict.get_or.#loop
  >chain
  >drop
} !dict.get_or

) dict.put: Insert or update key-value pair (red-black tree insert)
) AL: [key, value, dict, ...] -> [new_dict, ...]
{
  !_.dict !_.value !_.key

  ) Helper: Create a new red node
  ) AL: [key, value, ...] -> [node, ...]
  {
    !_.value !_.key
    _.key !_.n.key
    _.value !_.n.value
    True !_.n.color                      ) New nodes are red
    Nil !_.n.left
    Nil !_.n.right
    _.n.
  } !dict.put.#new_red

  ) Helper: Check if node is red
  ) AL: [node, ...] -> [bool, ...]
  {
    !_.node
    _.
    _.node >isNil
    { !_. False }
    { !_. _.node.color }
    >choose >^
  } !dict.put.#is_red

  ) Helper: Check if node's left child is red
  ) AL: [node, ...] -> [bool, ...]
  {
    !_.node
    _.
    _.node >isNil
    { !_. False }
    { !_. _.node.left >dict.put.#is_red }
    >choose >^
  } !dict.put.#left_is_red

  ) Helper: Left rotate
  ) AL: [node, ...] -> [new_root, ...]
  )     node              x
  )    /    \    ->     /   \
  )   a      x        node   c
  )         / \       /  \
  )        b   c     a    b
  ) After rotation: x takes node's color, node becomes red
  {
    !_.node
    _.node.right !_.x
    _.x.left !_.b
    ) Build new node (was root) - becomes red
    _.node.key !_.new_node.key
    _.node.value !_.new_node.value
    True !_.new_node.color                 ) Old root becomes red
    _.node.left !_.new_node.left
    _.b !_.new_node.right
    ) Build new x (new root) - takes old root's color
    _.x.key !_.new_x.key
    _.x.value !_.new_x.value
    _.node.color !_.new_x.color            ) New root takes old root's color
    _.new_node. !_.new_x.left
    _.x.right !_.new_x.right
    _.new_x.
  } !dict.put.#rotate_left

  ) Helper: Right rotate
  ) AL: [node, ...] -> [new_root, ...]
  )       node            x
  )      /    \   ->    /   \
  )     x      c       a    node
  )    / \                  /  \
  )   a   b                b    c
  ) After rotation: x takes node's color, node becomes red
  {
    !_.node
    _.node.left !_.x
    _.x.right !_.b
    ) Build new node (was root) - becomes red
    _.node.key !_.new_node.key
    _.node.value !_.new_node.value
    True !_.new_node.color                 ) Old root becomes red
    _.b !_.new_node.left
    _.node.right !_.new_node.right
    ) Build new x (new root) - takes old root's color
    _.x.key !_.new_x.key
    _.x.value !_.new_x.value
    _.node.color !_.new_x.color            ) New root takes old root's color
    _.x.left !_.new_x.left
    _.new_node. !_.new_x.right
    _.new_x.
  } !dict.put.#rotate_right

  ) Helper: Flip colors (node becomes red, children become black)
  ) AL: [node, ...] -> [new_node, ...]
  {
    !_.node
    ) Copy left child but make it black
    _.node.left.key !_.new_left.key
    _.node.left.value !_.new_left.value
    False !_.new_left.color
    _.node.left.left !_.new_left.left
    _.node.left.right !_.new_left.right
    ) Copy right child but make it black
    _.node.right.key !_.new_right.key
    _.node.right.value !_.new_right.value
    False !_.new_right.color
    _.node.right.left !_.new_right.left
    _.node.right.right !_.new_right.right
    ) Copy node but make it red
    _.node.key !_.new_node.key
    _.node.value !_.new_node.value
    True !_.new_node.color
    _.new_left. !_.new_node.left
    _.new_right. !_.new_node.right
    _.new_node.
  } !dict.put.#flip_colors

  ) Helper: Fix up after insert (maintain RB invariants)
  ) AL: [node, ...] -> [fixed_node, ...]
  ) Uses left-leaning red-black tree rules:
  ) 1. If right child is red and left child is black: rotate left
  ) 2. If left child is red and left-left grandchild is red: rotate right
  ) 3. If both children are red: flip colors
  {
    !_.node

    ) Case 1: Right child red, left child black -> rotate left
    _.
    _.node.right >dict.put.#is_red
    _.node.left >dict.put.#is_red >not
    >and
    {
      !_.
      _.node >dict.put.#rotate_left !_.node
    }
    { !_. }
    >choose >^

    ) Case 2: Left child red, left-left grandchild red -> rotate right
    ) Use helper to safely check if left.left is red
    _.
    _.node.left >dict.put.#is_red
    _.node.left >dict.put.#left_is_red
    >and
    {
      !_.
      _.node >dict.put.#rotate_right !_.node
    }
    { !_. }
    >choose >^

    ) Case 3: Both children red -> flip colors
    _.
    _.node.left >dict.put.#is_red
    _.node.right >dict.put.#is_red
    >and
    {
      !_.
      _.node >dict.put.#flip_colors !_.node
    }
    { !_. }
    >choose >^

    _.node
  } !dict.put.#fixup

  ) Helper: Recursive BST insert with fixup
  ) AL: [key, value, node, ...] -> [new_node, ...]
  {
    !_.node !_.value !_.key
    _.                                   ) Push context for choose
    _.node >isNil
    {
      !_.                                ) Pop context - create new red node
      _.key _.value >dict.put.#new_red
    }
    {
      !_.                                ) Pop context
      _.                                 ) Push context for comparison
      _.key _.node.key >==
      {
        !_.                              ) Pop context - update existing
        _.key !_.upd.key
        _.value !_.upd.value
        _.node.color !_.upd.color
        _.node.left !_.upd.left
        _.node.right !_.upd.right
        _.upd.
      }
      {
        !_.                              ) Pop context
        _.
        _.key _.node.key ><              ) key < node.key
        {
          !_.                            ) Insert in left subtree
          _.key _.value _.node.left >dict.put.#insert
          !_.new_left
          _.node.key !_.nl.key
          _.node.value !_.nl.value
          _.node.color !_.nl.color
          _.new_left !_.nl.left
          _.node.right !_.nl.right
          _.nl. >dict.put.#fixup
        }
        {
          !_.                            ) Insert in right subtree
          _.key _.value _.node.right >dict.put.#insert
          !_.new_right
          _.node.key !_.nr.key
          _.node.value !_.nr.value
          _.node.color !_.nr.color
          _.node.left !_.nr.left
          _.new_right !_.nr.right
          _.nr. >dict.put.#fixup
        }
        >choose >^
      }
      >choose >^
    }
    >choose >^
  } !dict.put.#insert

  ) Main insert: call recursive insert, then make root black
  _.key _.value _.dict >dict.put.#insert
  !_.result
  ) Make root black
  _.result.key !_.root.key
  _.result.value !_.root.value
  False !_.root.color
  _.result.left !_.root.left
  _.result.right !_.root.right
  _.root.
} !dict.put

) dict.remove: Remove key from dictionary (red-black tree delete)
) AL: [key, dict, ...] -> [new_dict, ...]
) Implementation: Collect all entries except the removed key, rebuild tree
) This is simpler than full RB delete and maintains all invariants
{
  !_.dict !_.key

  ) Helper: Collect all key-value pairs into a list (in-order traversal)
  ) AL: [node, acc, ...] -> [list, ...]
  {
    !_.acc !_.node
    _.
    _.node >isNil
    {
      !_.
      _.acc
      Nil
    }
    {
      !_.
      ) In-order: left, then node, then right
      _.node.left _.acc >dict.remove.#collect
      !_.left_acc
      ) Add current node's key-value to accumulator
      _.node.key !_.pair.key
      _.node.value !_.pair.value
      _.left_acc !_.pair.next
      _.node.right _.pair. >dict.remove.#collect
      Nil
    }
    >choose >^
  } !dict.remove.#collect

  ) Helper: Build tree from list of key-value pairs
  ) AL: [list, tree, ...] -> [tree, ...]
  {
    !_.tree !_.list
    _.
    _.list >isNil
    {
      !_.
      _.tree
      Nil
    }
    {
      !_.
      _.list.key _.list.value _.tree >dict.put
      _.list.next
      dict.remove.#rebuild
    }
    >choose >^
  } !dict.remove.#rebuild

  ) Helper: Filter out the key to remove
  ) AL: [list, key, acc, ...] -> [filtered, ...]
  {
    !_.acc !_.key !_.list
    _.
    _.list >isNil
    {
      !_.
      _.acc
      Nil
    }
    {
      !_.
      _.
      _.list.key _.key >==
      {
        !_.
        ) Skip this entry
        _.list.next _.key _.acc
        dict.remove.#filter
      }
      {
        !_.
        ) Keep this entry
        _.list.key !_.kept.key
        _.list.value !_.kept.value
        _.acc !_.kept.next
        _.list.next _.key _.kept.
        dict.remove.#filter
      }
      >choose >^
    }
    >choose >^
  } !dict.remove.#filter

  ) Main: collect all, filter out key, rebuild tree
  _.dict Nil >dict.remove.#collect
  >chain >drop
  !_.all_pairs

  _.all_pairs _.key Nil >dict.remove.#filter
  >chain >drop
  !_.filtered

  _.filtered Nil >dict.remove.#rebuild
  >chain >drop
} !dict.remove

) dict.size: Count entries in dictionary (tree traversal)
) AL: [dict, ...] -> [count, ...]
{
  !_.node
  _.
  _.node >isNil
  {
    !_.
    0
  }
  {
    !_.
    _.node.left >dict.size
    _.node.right >dict.size
    >+ 1 >+                              ) left_count + right_count + 1
  }
  >choose >^
} !dict.size

) dict.keys: Get list of all keys (in-order traversal)
) AL: [dict, ...] -> [list, ...]
{
  ) Helper: in-order traversal collecting keys
  ) AL: [node, acc, ...] -> [list, ...]
  {
    !_.acc !_.node
    _.
    _.node >isNil
    {
      !_.
      _.acc
    }
    {
      !_.
      ) In-order: left, then node, then right
      ) Process right first (will be at end of list)
      _.node.right _.acc >dict.keys.#collect
      !_.right_acc
      ) Add current key
      _.node.key _.right_acc >list.cons
      !_.mid_acc
      ) Process left (will be at start of list)
      _.node.left _.mid_acc >dict.keys.#collect
    }
    >choose >^
  } !dict.keys.#collect

  !_.dict
  _.dict Nil >dict.keys.#collect
} !dict.keys

) dict.values: Get list of all values (in-order traversal)
) AL: [dict, ...] -> [list, ...]
{
  ) Helper: in-order traversal collecting values
  ) AL: [node, acc, ...] -> [list, ...]
  {
    !_.acc !_.node
    _.
    _.node >isNil
    {
      !_.
      _.acc
    }
    {
      !_.
      ) In-order: left, then node, then right
      ) Process right first (will be at end of list)
      _.node.right _.acc >dict.values.#collect
      !_.right_acc
      ) Add current value
      _.node.value _.right_acc >list.cons
      !_.mid_acc
      ) Process left (will be at start of list)
      _.node.left _.mid_acc >dict.values.#collect
    }
    >choose >^
  } !dict.values.#collect

  !_.dict
  _.dict Nil >dict.values.#collect
} !dict.values

) dict.fold: Fold over dictionary entries (in-order traversal)
) AL: [folder, init, dict, ...] -> [result, ...]
) folder receives [key, value, acc, ...] and returns new acc
{
  ) Helper: in-order fold with folder passed through
  ) AL: [node, acc, folder, ...] -> [result, ...]
  {
    !_.folder !_.acc !_.node
    _.
    _.node >isNil
    {
      !_.
      _.acc
    }
    {
      !_.
      ) In-order: left, then node, then right
      ) First fold left subtree
      _.node.left _.acc _.folder >dict.fold.#traverse
      !_.left_acc
      ) Apply folder to current node
      _.node.key _.node.value _.left_acc _.folder >^
      !_.mid_acc
      ) Fold right subtree
      _.node.right _.mid_acc _.folder >dict.fold.#traverse
    }
    >choose >^
  } !dict.fold.#traverse

  !_.dict !_.init !_.folder
  _.dict _.init _.folder >dict.fold.#traverse
} !dict.fold

