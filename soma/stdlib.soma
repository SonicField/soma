) SOMA Standard Library
) Derived operations built from FFI primitives

) ==================== Boolean Logic ====================

) not: Boolean negation
{False True >choose} !not

) and: Logical AND
{False >choose} !and

) or: Logical OR
{True >swap >choose} !or

) ==================== Comparison Operators ====================

) Greater-than: execute as >>
{>swap ><} !>

) Not equal: execute as >=!
{>over >over >swap >< >rot >rot >< >or} !=!

) Equality: execute as >==
{>=! >not} !==

) Less-than-or-equal: execute as >=<
{>swap >< >not} !=<

) Greater-than-or-equal: execute as >=>
{>< >not} !=>

) ==================== Stack Manipulation ====================

) dup: Duplicate top
{!_.value _.value _.value} !dup

) drop: Remove top
{!_} !drop

) swap: Swap top two
{!_.a !_.b _.a _.b} !swap

) over: Copy second to top
{!_.a !_.b _.b _.a _.b} !over

) rot: Rotate top three
{!_.a !_.b !_.c _.b _.a _.c} !rot

) ==================== Arithmetic Helpers ====================

) inc: Increment by 1
{1 >+} !inc

) dec: Decrement by 1
{1 >-} !dec

) abs: Absolute value
{>dup 0 >< {0 >swap >-} {} >choose >^} !abs

) min: Minimum of two values
{>over >over >< {>drop} {>swap >drop} >choose >^} !min

) max: Maximum of two values
{>over >over >> {>drop} {>swap >drop} >choose >^} !max

) ==================== Control Flow Helpers ====================

) times: Execute block N times
) AL: [n, block, ...] -> [...]
) Usage: 10 { (Hello) >print } >times
{
  {
    !_.user_blk !_.cnt
    >_.user_blk
    _.cnt 1 >-
    !_.new_cnt
    _.new_cnt _.user_blk
    >block
    0 _.new_cnt ><
    {}
    {>drop >drop >drop Nil}
    >choose >^
  } >chain
  >drop
} !times

) if: Execute block if condition is true
) AL: [condition, block, ...] -> [...]
) Usage: True { (Hello) >print } >if
{{} >choose >^} !if

) ifelse: Conditional with both branches (alias for choose)
) AL: [condition, true_block, false_block, ...] -> [...]
) Usage: x 0 >< { (positive) } { (not positive) } >ifelse
{>choose >^} !ifelse

) ^: Execute from AL (like Forth's EXECUTE)
) AL: [block, ...] -> [result, ...]
{ !_ >_ } !^

) while: Loop while condition is true
) AL: [cond_block, body_block, ...] -> [...]
) Usage: { count 10 >< } { count >print count >inc } >while
{
  {
    !_.body !_.cond
    _.cond _.body                 ) Push state back onto AL
    >block                        ) Push loop block
    >_.cond                       ) Execute condition LAST so bool is on top
    {
      !_.loop !_.body !_.cond     ) Pop state from AL (choose already popped)
      >_.body                     ) Execute body
      _.cond _.body _.loop        ) Push state back for next iteration
    }
    {>drop >drop >drop Nil}       ) False: cleanup
    >choose >^
  } >chain
  >drop
} !while

) do: Execute body first, then loop while condition is true
) AL: [body_block, cond_block, ...] -> [...]
) Usage: { count >print count >inc } { count 10 >< } >do
{
  {
    !_.cond !_.body
    >_.body                       ) Execute body first
    _.body _.cond                 ) Push state back onto AL
    >block                        ) Push loop block
    >_.cond                       ) Execute condition LAST so bool is on top
    {}                            ) True: empty (state already on AL)
    {>drop >drop >drop Nil}       ) False: cleanup
    >choose >^
  } >chain
  >drop
} !do

) ==================== Linked List Operations ====================
) Linked lists using CellRefs and context-passing style
) Empty list is Nil, nodes have .value and .next

) list.new: Create empty list
) AL: [...] -> [Nil, ...]
{
  Nil
} !list.new

) list.cons: Prepend value to list (functional cons)
) AL: [value, list, ...] -> [new_node, ...]
) Creates new node with value, next points to list
) Pure CellRef implementation - node lives in this block's Register
{
  !_.list !_.value  ) Pop list first (top), then value
  _.value !_.node.value
  _.list !_.node.next
  _.node.  ) Return CellRef to the node (persists after block!)
} !list.cons

) ==================== AL Draining Operations ====================

) al.drain: Drain AL until Void, applying action to each item
) AL: [void, item1, item2, ..., itemN, persistent, action_block, ...] -> [...]
) The action_block receives: [current, persistent, ...] on AL
) Core state transformer: AL -> AL'
{
  {
    !_.todo !_.persistent !_.current    ) Pop action, persistent, current

    ) Put context on AL for choose blocks
    _.
    _.current >isVoid                   ) Check: AL=[bool, CTX, ...rest]
    {
      ) Void - cleanup and stop
      >drop                             ) Drop context
      Nil                               ) Stop chain
    }
    {
      ) Not void - process and continue
      !_.                               ) Pop context
      _.current _.persistent _.todo >^  ) Execute action with args
      _.persistent _.todo               ) Push state for next iteration
      al.drain#loop                     ) AL=[loop, todo, persistent, ...rest]
    }
    >choose
  } !al.drain.#loop

  al.drain.#loop >^
  >chain
  >drop
} !al.drain

) ==================== List Transformations ====================

) list.from_al: Drain AL into linked list
) AL: [void, items..., ...] -> [list, ...]
) Uses al.drain with list.cons to build list from AL items
) Preserves AL order: Void (a) (b) (c) -> list (a,b,c)
{
  Nil { !_.persistent !_.current _.current _.persistent >list.cons } >al.drain
} !list.from_al

) list.to_al: Push list items onto AL
) AL: [list, ...] -> [items..., ...]
) Traverses list, pushes each .value onto AL
) Preserves order: list (a,b,c) -> AL: [(a), (b), (c)]
{
  !_.list
  {
    !_.
    _.
    _.list >isNil
    {
      ) End of list
      !_.
      Nil
    }
    {
      ) Not empty - push value and continue
      !_.
      _.list.value                ) Push value onto AL
      _.list.next !_.list         ) Move to next
      _.
      list.to_al.#loop
    }
    >choose
  } !list.to_al.#loop

  _.
  list.to_al.#loop >^
  >chain
  >drop
} !list.to_al

) list.reverse: Reverse a list by copying
) AL: [list, ...] -> [reversed_list, ...]
) Traverses original, conses onto new list
) Reverses order: (a,b,c) -> (c,b,a)
{
  !_.old_list
  Nil !_.new_list

  {
    !_.
    _.
    _.old_list >isNil
    {
      ) End - return accumulated list
      !_.
      _.new_list
      Nil
    }
    {
      ) Not empty - cons value onto new list
      !_.
      _.old_list.value _.new_list >list.cons
      !_.new_list
      _.old_list.next !_.old_list
      _.
      list.reverse.#loop
    }
    >choose
  } !list.reverse.#loop

  _.
  list.reverse.#loop >^
  >chain
  >drop
} !list.reverse

