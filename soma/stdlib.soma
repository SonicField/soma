) SOMA Standard Library
) Derived operations built from FFI primitives

) ==================== Boolean Logic ====================

) not: Boolean negation
{False True >choose} !not

) and: Logical AND
{False >choose} !and

) or: Logical OR
{True >swap >choose} !or

) ==================== Comparison Operators ====================

) Greater-than: execute as >>
{>swap ><} !>

) Not equal: execute as >=!
{>over >over >swap >< >rot >rot >< >or} !=!

) Equality: execute as >==
{>=! >not} !==

) Less-than-or-equal: execute as >=<
{>swap >< >not} !=<

) Greater-than-or-equal: execute as >=>
{>< >not} !=>

) ==================== Stack Manipulation ====================

) dup: Duplicate top
{!_.value _.value _.value} !dup

) drop: Remove top
{!_} !drop

) swap: Swap top two
{!_.a !_.b _.a _.b} !swap

) over: Copy second to top
{!_.a !_.b _.b _.a _.b} !over

) rot: Rotate top three
{!_.a !_.b !_.c _.b _.a _.c} !rot

) ==================== Arithmetic Helpers ====================

) inc: Increment by 1
{1 >+} !inc

) dec: Decrement by 1
{1 >-} !dec

) abs: Absolute value
{>dup 0 >< {0 >swap >-} {} >choose >^} !abs

) min: Minimum of two values
{>over >over >< {>drop} {>swap >drop} >choose >^} !min

) max: Maximum of two values
{>over >over >> {>drop} {>swap >drop} >choose >^} !max

) ==================== Control Flow Helpers ====================

) times: Execute block N times
) AL: [n, block, ...] -> [...]
) Usage: 10 { (Hello) >print } >times
{
  {
    !_.user_blk !_.cnt
    >_.user_blk
    _.cnt 1 >-
    !_.new_cnt
    _.new_cnt _.user_blk
    >block
    0 _.new_cnt ><
    {}
    {>drop >drop >drop Nil}
    >choose >^
  } >chain
  >drop
} !times

) if: Execute block if condition is true
) AL: [condition, block, ...] -> [...]
) Usage: True { (Hello) >print } >if
{{} >choose >^} !if

) ifelse: Conditional with both branches (alias for choose)
) AL: [condition, true_block, false_block, ...] -> [...]
) Usage: x 0 >< { (positive) } { (not positive) } >ifelse
{>choose >^} !ifelse

) ^: Execute from AL (like Forth's EXECUTE)
) AL: [block, ...] -> [result, ...]
{ !_ >_ } !^

) while: Loop while condition is true
) AL: [cond_block, body_block, ...] -> [...]
) Usage: { count 10 >< } { count >print count >inc } >while
{
  {
    !_.body !_.cond
    _.cond _.body                 ) Push state back onto AL
    >block                        ) Push loop block
    >_.cond                       ) Execute condition LAST so bool is on top
    {
      !_.loop !_.body !_.cond     ) Pop state from AL (choose already popped)
      >_.body                     ) Execute body
      _.cond _.body _.loop        ) Push state back for next iteration
    }
    {>drop >drop >drop Nil}       ) False: cleanup
    >choose >^
  } >chain
  >drop
} !while

) do: Execute body first, then loop while condition is true
) AL: [body_block, cond_block, ...] -> [...]
) Usage: { count >print count >inc } { count 10 >< } >do
{
  {
    !_.cond !_.body
    >_.body                       ) Execute body first
    _.body _.cond                 ) Push state back onto AL
    >block                        ) Push loop block
    >_.cond                       ) Execute condition LAST so bool is on top
    {}                            ) True: empty (state already on AL)
    {>drop >drop >drop Nil}       ) False: cleanup
    >choose >^
  } >chain
  >drop
} !do

) ==================== Linked List Operations ====================
) Linked lists using CellRefs and context-passing style
) Empty list is Nil, nodes have .value and .next

) list.new: Create empty list
) AL: [...] -> [Nil, ...]
{
  Nil
} !list.new

) list.cons: Prepend value to list (functional cons)
) AL: [value, list, ...] -> [new_node, ...]
) Creates new node with value, next points to list
) Pure CellRef implementation - node lives in this block's Register
{
  !_.list !_.value  ) Pop list first (top), then value
  _.value !_.node.value
  _.list !_.node.next
  _.node.  ) Return CellRef to the node (persists after block!)
} !list.cons

) ==================== AL Draining Operations ====================

) al.drain: Drain AL until Void, applying action to each item
) AL: [void, item1, item2, ..., itemN, persistent, action_block, ...] -> [...]
) The action_block receives: [current, persistent, ...] on AL
) Core state transformer: AL -> AL'
{
  {
    !_.todo !_.persistent !_.current    ) Pop action, persistent, current

    ) Put context on AL for choose blocks
    _.
    _.current >isVoid                   ) Check: AL=[bool, CTX, ...rest]
    {
      ) Void - cleanup and stop
      !_.                               ) Pop context
      _.persistent                      ) Leave persistent on AL
      Nil                               ) Stop chain
    }
    {
      ) Not void - process and continue
      !_.                               ) Pop context
      _.current _.persistent _.todo >^  ) Execute action: AL=[persistent, current, ...]
      _.todo                            ) Just push todo (new_persistent already on AL)
      al.drain.#loop                    ) AL=[loop, todo, new_persistent, ...rest]
    }
    >choose
  } !al.drain.#loop

  al.drain.#loop >^
  >chain
  >drop
} !al.drain

) ==================== List Transformations ====================

) list.from_al: Drain AL into linked list
) AL: [void, items..., ...] -> [list, ...]
) Uses al.drain with list.cons to build list from AL items
) Preserves AL order: Void (a) (b) (c) -> list (a,b,c)
{
  >list.new { !_.persistent !_.current _.current _.persistent >list.cons } >al.drain
} !list.from_al

) list.to_al: Push list items onto AL
) AL: [list, ...] -> [items..., ...]
) Traverses list, pushes each .value onto AL
) Preserves order: list (a,b,c) -> AL: [(a), (b), (c)]
{
  {
    !_.list                       ) Pop list node from AL
    _.list                        ) Save for isNil check
    _.list >isNil                 ) Check if Nil: AL=[bool, list_node]
    {
      ) True branch: list is Nil
      !_.                         ) Pop the list_node
      Nil                         ) Return Nil to stop chain
    }
    {
      ) False branch: list is not Nil
      !_.node                      ) Pop and save the list_node
      _.node.value                ) Get value and push to AL
      _.node.next                 ) Get next node and push to AL
      list.to_al.#loop            ) Push loop block for next iteration
    }
    >choose
  } !list.to_al.#loop

  list.to_al.#loop
  >chain
  >drop
} !list.to_al

) list.reverse: Reverse a list by copying
) AL: [list, ...] -> [reversed_list, ...]
) Traverses original, conses onto new list
) Reverses order: (a,b,c) -> (c,b,a)
) Uses context-passing: each iteration receives [old_list, new_list, ...] on AL
{
  {
    !_.old_list !_.new_list       ) Pop in LIFO order: top is old_list (pushed second), next is new_list (pushed first)
    _.                            ) Push Register context onto AL for choose branches
    _.old_list >isNil             ) Check: AL=[bool, CTX, ...]
    {
      !_.                         ) Pop Register context from previous block
      ) Nil - return accumulated list
      _.new_list                  ) Return result
      Nil                         ) Stop chain
    }
    {
      !_.                         ) Pop Register context from previous block
      ) Not Nil - cons and continue
      _.old_list.value _.new_list >list.cons  ) Create new_list with value consed
      !_.new_new_list                         ) Save it
      _.new_new_list _.old_list.next          ) Push for next iteration in correct order: new_list first, old_list second
      list.reverse.#loop                      ) Push loop block from Store
    }
    >choose
  } !list.reverse.#loop

  Nil >swap                       ) AL=[original_list, Nil, ...] → swap → AL=[Nil, original_list, ...]
  list.reverse.#loop                ) Initial push from Store
  >chain
  >drop
} !list.reverse

