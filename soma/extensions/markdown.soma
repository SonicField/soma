) ============================================================================
) Markdown Extension - Pure SOMA Implementation
) ============================================================================
) Provides markdown generation with state machine and nesting support

) Note: >md.drain.join is registered as a Python builtin in markdown.py

) Initialize state machine and push Void sentinel
{
  () !md.state.doc        ) Accumulated document (empty string)

  ) Create empty stack for nesting
  Void (soma.extensions.soma_markdown.list_new) >use.python.call
  !_.exception !_.stack
  _.stack !md.state.stack

  0 !md.state.depth       ) Nesting depth starts at 0

  ) Initialize table state
  Void (soma.extensions.soma_markdown.list_new) >use.python.call
  !_.exception !_.empty_list
  _.empty_list !md.state.table.header
  _.empty_list !md.state.table.rows
  _.empty_list !md.state.table.alignment

  Void                     ) Push Void sentinel to bottom of AL
} !md.start

) H1 heading
{
  ( ) >use.md.drain.join
  !_.text

  ) Create markdown: "# text\n\n"
  md.state.doc !_.doc
  Void _.doc (# ) _.text (\a\\a\) (soma.extensions.soma_markdown.string_concat_all) >use.python.call
  !_.exc !_.new_doc
  _.new_doc !md.state.doc

  Void  ) Push sentinel back
} !md.h1

) H2 heading
{
  ( ) >use.md.drain.join
  !_.text

  md.state.doc !_.doc
  Void _.doc (## ) _.text (\a\\a\) (soma.extensions.soma_markdown.string_concat_all) >use.python.call
  !_.exc !_.new_doc
  _.new_doc !md.state.doc

  Void
} !md.h2

) H3 heading
{
  ( ) >use.md.drain.join
  !_.text

  md.state.doc !_.doc
  Void _.doc (### ) _.text (\a\\a\) (soma.extensions.soma_markdown.string_concat_all) >use.python.call
  !_.exc !_.new_doc
  _.new_doc !md.state.doc

  Void
} !md.h3

) H4 heading
{
  ( ) >use.md.drain.join
  !_.text

  md.state.doc !_.doc
  Void _.doc (#### ) _.text (\a\\a\) (soma.extensions.soma_markdown.string_concat_all) >use.python.call
  !_.exc !_.new_doc
  _.new_doc !md.state.doc

  Void
} !md.h4

) Paragraph - each string becomes a separate paragraph
{
  >use.md.drain.p
  !_.text

  md.state.doc !_.doc
  Void _.doc _.text (soma.extensions.soma_markdown.string_concat_all) >use.python.call
  !_.exc !_.new_doc
  _.new_doc !md.state.doc

  Void
} !md.p

) Blockquote - each string becomes a quoted line
{
  >use.md.drain.q
  !_.text

  md.state.doc !_.doc
  Void _.doc _.text (soma.extensions.soma_markdown.string_concat_all) >use.python.call
  !_.exc !_.new_doc
  _.new_doc !md.state.doc

  Void
} !md.q

) Code block - formats lines as fenced code block with optional language
{
  >use.md.drain.code
  !_.text

  md.state.doc !_.doc
  Void _.doc _.text (soma.extensions.soma_markdown.string_concat_all) >use.python.call
  !_.exc !_.new_doc
  _.new_doc !md.state.doc

  Void
} !md.code

) Horizontal rule - inserts --- separator
{
  md.state.doc !_.doc
  Void _.doc (---\a\\a\) (soma.extensions.soma_markdown.string_concat_all) >use.python.call
  !_.exc !_.new_doc
  _.new_doc !md.state.doc

  Void
} !md.hr

) ============================================================================
) Inline Formatting
) ============================================================================

) Bold - wraps text in **text**
{
  !_.text
  (**) !_.prefix
  (**) !_.suffix
  Void _.prefix _.text _.suffix (soma.extensions.soma_markdown.string_concat_all) >use.python.call
  !_.exc !_.result
  _.result
} !md.b

) Italic - wraps text in _text_
{
  !_.text
  (_) !_.prefix
  (_) !_.suffix
  Void _.prefix _.text _.suffix (soma.extensions.soma_markdown.string_concat_all) >use.python.call
  !_.exc !_.result
  _.result
} !md.i

) Inline code - wraps text in `text`
{
  !_.text
  (`) !_.prefix
  (`) !_.suffix
  Void _.prefix _.text _.suffix (soma.extensions.soma_markdown.string_concat_all) >use.python.call
  !_.exc !_.result
  _.result
} !md.c

) Link - creates [text](url)
{
  !_.url !_.text
  ) Build [text](url) format
  ([) !_.left
  (]() !_.middle

  ) Concatenate: [ + text + ]( + url + )
  Void _.left _.text _.middle _.url (soma.extensions.soma_markdown.link_format) >use.python.call
  !_.exc !_.result
  _.result
} !md.l

) Inline text - concatenates strings (for inline use)
{
  () >use.md.drain.join
} !md.t

) Data title - alternating bold formatting (PURE SOMA)
) Drains AL, transforms pairs with alternating bold, concatenates with spaces
) Example: (a) (b) (c) (d) >md.dt → **a** b **c** d
{
  ) Build linked list by draining AL (using Store for loop state)
  Nil !md.dt.list
  0 !md.dt.counter
  {
    >dup >isVoid >not
  } {
    !_.item

    ) Create new node with unique path using counter
    _.item !md.dt.temp.value
    md.dt.list !md.dt.temp.next
    md.dt.temp. !md.dt.list

    md.dt.counter 1 >+ !md.dt.counter
  } >while

  >drop  ) Drop the Void

  ) Walk list and build result string with transformations
  () !md.dt.result
  0 !md.dt.index
  {
    md.dt.list >isNil >not
  } {
    ) Get current item
    md.dt.list.value

    ) Apply bold to even indices (0, 2, 4...)
    md.dt.index 2 >% 0 >=
      { >md.b }
      { }
    >ifelse

    ) Add to result with space separator (except first item)
    md.dt.index 0 >>
      { ( ) md.dt.result >concat >concat !md.dt.result }
      { !md.dt.result }
    >ifelse

    md.dt.index 1 >+ !md.dt.index
    md.dt.list.next !md.dt.list
  } >while

  ) Push Void and result back to AL
  Void
  md.dt.result
} !md.dt

) Definition list - transforms pairs into separate "**label**: value" items (PURE SOMA)
) Example: (a) (b) (c) (d) >md.dl → (**a**: b) (**c**: d) on AL
{
  ) Build linked list by draining AL (using Store for loop state)
  Nil !md.dl.list
  {
    >dup >isVoid >not
  } {
    !_.item
    _.item !_.node.value
    md.dl.list !_.node.next
    _.node. !_.node
    _.node !md.dl.list
  } >while

  >drop  ) Drop the Void

  ) Walk list in pairs and format
  Void  ) Push sentinel first
  Nil !md.dl.first
  0 !md.dl.index
  {
    md.dl.list >isNil >not
  } {
    md.dl.index 2 >% 0 >=
      {
        ) Even index - save as first of pair (label)
        md.dl.list.value !md.dl.first
      }
      {
        ) Odd index - combine with first to make "**label**: value"
        md.dl.first >md.b (:_) >concat md.dl.list.value >concat
      }
    >ifelse

    md.dl.index 1 >+ !md.dl.index
    md.dl.list.next !md.dl.list
  } >while
} !md.dl

) Definition unordered list - combines md.dl with md.ul
) Example: (a) (b) (c) (d) >md.dul → unordered list of **a**: b, **c**: d
{
  >md.dl >md.ul
} !md.dul

) Definition ordered list - combines md.dl with md.ol
) Example: (a) (b) (c) (d) >md.dol → ordered list of **a**: b, **c**: d
{
  >md.dl >md.ol
} !md.dol

) ============================================================================
) Tables
) ============================================================================

) Table alignment markers
{
  (left)
} !md.table.left

{
  (centre)
} !md.table.centre

{
  (right)
} !md.table.right

) Table header - drains AL and saves cells as array
{
  >use.md.table.drain.cells
  !_.cells
  _.cells !md.state.table.header
  Void
} !md.table.header

) Table alignment - drains AL and saves alignment array
{
  >use.md.table.drain.cells
  !_.alignments
  _.alignments !md.state.table.alignment
  Void
} !md.table.align

) Table row - drains AL and appends row to table
{
  >use.md.table.drain.cells
  !_.row

  md.state.table.rows !_.rows
  Void _.rows _.row (soma.extensions.soma_markdown.list_append) >use.python.call
  !_.exc !_.new_rows
  _.new_rows !md.state.table.rows

  Void
} !md.table.row

) Table - renders complete table and clears state
{
  md.state.table.header !_.header
  md.state.table.rows !_.rows
  md.state.table.alignment !_.alignment

  ) Render table using Python builtin
  Void _.header _.rows _.alignment (soma.extensions.soma_markdown.render_table) >use.python.call
  !_.exc !_.table_text

  ) Append to document
  md.state.doc !_.doc
  Void _.doc _.table_text (soma.extensions.soma_markdown.string_concat_all) >use.python.call
  !_.exc !_.new_doc
  _.new_doc !md.state.doc

  ) Clear table state
  Void (soma.extensions.soma_markdown.list_new) >use.python.call
  !_.exc !_.empty
  _.empty !md.state.table.header
  _.empty !md.state.table.rows
  _.empty !md.state.table.alignment

  Void
} !md.table

) ============================================================================
) Lists
) ============================================================================

) Unordered list
{
  ) Push depth and stack onto AL for builtin
  md.state.depth md.state.stack
  >use.md.drain.ul
  !_.list_text !_.new_depth !_.new_stack

  ) Update state with new depth and stack
  _.new_depth !md.state.depth
  _.new_stack !md.state.stack

  ) Append list text to document
  md.state.doc !_.doc
  Void _.doc _.list_text (soma.extensions.soma_markdown.string_concat_all) >use.python.call
  !_.exc !_.new_doc
  _.new_doc !md.state.doc

  Void
} !md.ul

) Ordered list
{
  ) Push depth and stack onto AL for builtin
  md.state.depth md.state.stack
  >use.md.drain.ol
  !_.list_text !_.new_depth !_.new_stack

  ) Update state with new depth and stack
  _.new_depth !md.state.depth
  _.new_stack !md.state.stack

  ) Append list text to document
  md.state.doc !_.doc
  Void _.doc _.list_text (soma.extensions.soma_markdown.string_concat_all) >use.python.call
  !_.exc !_.new_doc
  _.new_doc !md.state.doc

  Void
} !md.ol

) Nesting - saves items as pending and increases depth (GENERIC - does not render)
{
  >use.md.nest
  ) Builtin handles everything: drains AL, saves to md.state.pending, increases md.state.depth
  ) Void is already back on AL
} !md.nest

) Render final document to file
{
  !_.filename

  ) Get accumulated document
  md.state.doc
  !_.content

  ) Write to file using Python FFI
  Void _.filename _.content (soma.extensions.soma_markdown.write_file) >use.python.call
  !_.exception !_.result

  ) Check if write succeeded
  _.
  _.exception >isVoid
  {
    ) Success - clean up state
    >{
      !_.
      () !md.state.doc

      Void (soma.extensions.soma_markdown.list_new) >use.python.call
      !_.exc !_.empty_list
      _.empty_list !md.state.stack

      0 !md.state.depth
    }
  }
  {
    ) Error
    >{
      !_.
      (Error writing markdown file: ) >print
      _.exception >print
      _.exception >drop
    }
  }
  >choose >^
} !md.render

) Print document to stdout - outputs generated markdown and cleans up state
{
  md.state.doc >print

  ) Clean up state
  () !md.state.doc

  Void (soma.extensions.soma_markdown.list_new) >use.python.call
  !_.exc !_.empty_list
  _.empty_list !md.state.stack

  0 !md.state.depth

  Void
} !md.print
