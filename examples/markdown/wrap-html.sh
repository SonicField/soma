#!/bin/bash

################################################################################
# wrap-html.sh - Wrap SOMA-generated HTML with stylesheet and document structure
################################################################################
#
# Usage:
#   ./wrap-html.sh [--inline] input.html [output.html]
#   ./wrap-html.sh input.html  (outputs to input-styled.html with linked CSS)
#   ./wrap-html.sh --inline input.html  (standalone with inlined CSS)
#
# Description:
#   Takes raw HTML content generated by SOMA's HtmlEmitter and wraps it in
#   a complete HTML document with the soma-document.css stylesheet.
#
# Options:
#   --inline     - Inline CSS into document (creates standalone HTML)
#   --standalone - Alias for --inline
#
# Arguments:
#   input.html   - File containing SOMA-generated HTML (required)
#   output.html  - Output file path (optional, defaults to input-styled.html)
#
# Example:
#   soma my-document.soma                    # Generates my-document.html
#   ./wrap-html.sh my-document.html          # Creates my-document-styled.html (linked CSS)
#   ./wrap-html.sh --inline my-document.html # Creates standalone my-document-styled.html
#
################################################################################

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Default mode
INLINE_CSS=false

# Function to print usage
usage() {
    echo "Usage: $0 [--inline] input.html [output.html]"
    echo ""
    echo "Wraps SOMA-generated HTML with stylesheet and document structure."
    echo ""
    echo "Options:"
    echo "  --inline, --standalone  Inline CSS for standalone document"
    echo ""
    echo "Arguments:"
    echo "  input.html   - File containing SOMA-generated HTML content"
    echo "  output.html  - Output file (optional, defaults to input-styled.html)"
    echo ""
    echo "Examples:"
    echo "  $0 my-document.html                    # Linked CSS"
    echo "  $0 --inline my-document.html           # Standalone with inlined CSS"
    echo "  $0 --inline my-doc.html output.html    # Standalone to custom path"
    exit 1
}

# Function to print error and exit
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

# Function to print success message
success() {
    echo -e "${GREEN}✓ $1${NC}"
}

# Function to print info message
info() {
    echo -e "${YELLOW}→ $1${NC}"
}

# Parse options
while [[ $# -gt 0 ]]; do
    case "$1" in
        --inline|--standalone)
            INLINE_CSS=true
            shift
            ;;
        -h|--help)
            usage
            ;;
        -*)
            error "Unknown option: $1"
            ;;
        *)
            break
            ;;
    esac
done

# Check arguments
if [ $# -lt 1 ]; then
    usage
fi

INPUT_FILE="$1"

# Check if input file exists
if [ ! -f "$INPUT_FILE" ]; then
    error "Input file not found: $INPUT_FILE"
fi

# Determine output file
if [ $# -ge 2 ]; then
    OUTPUT_FILE="$2"
else
    # Default: replace .html with -styled.html, or append -styled.html
    if [[ "$INPUT_FILE" == *.html ]]; then
        OUTPUT_FILE="${INPUT_FILE%.html}-styled.html"
    else
        OUTPUT_FILE="${INPUT_FILE}-styled.html"
    fi
fi

# Get the directory where this script lives (for finding CSS)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CSS_FILE="$SCRIPT_DIR/soma-document.css"

# Check if CSS file exists
if [ ! -f "$CSS_FILE" ]; then
    error "CSS file not found: $CSS_FILE"
fi

# Get output directory for later use
OUTPUT_DIR="$(cd "$(dirname "$OUTPUT_FILE")" 2>/dev/null && pwd)" || OUTPUT_DIR="."

# Prepare CSS (read it if inlining, or calculate path if linking)
if [ "$INLINE_CSS" = true ]; then
    CSS_CONTENT=$(cat "$CSS_FILE")
    CSS_INFO="inlined"
else
    # Determine CSS path relative to output file
    if [ "$OUTPUT_DIR" = "$SCRIPT_DIR" ]; then
        CSS_PATH="soma-document.css"
    else
        # Try to create relative path, or use absolute
        CSS_PATH="$(realpath --relative-to="$OUTPUT_DIR" "$CSS_FILE" 2>/dev/null)" || CSS_PATH="$CSS_FILE"
    fi
    CSS_INFO="linked to $CSS_PATH"
fi

info "Reading: $INPUT_FILE"
info "Writing: $OUTPUT_FILE"
info "CSS: $CSS_INFO"

# Read the input HTML content
CONTENT=$(cat "$INPUT_FILE")

# Extract title from first h1 if present, otherwise use filename
TITLE="SOMA Document"
if echo "$CONTENT" | grep -q '<h1>'; then
    # Extract text from first h1 tag
    TITLE=$(echo "$CONTENT" | grep -o '<h1>[^<]*</h1>' | head -1 | sed 's/<[^>]*>//g' || echo "SOMA Document")
fi

# If title is empty, use filename
if [ -z "$TITLE" ] || [ "$TITLE" = "SOMA Document" ]; then
    TITLE=$(basename "$INPUT_FILE" .html)
fi

# Generate the complete HTML document
if [ "$INLINE_CSS" = true ]; then
    # Standalone document with inlined CSS
    cat > "$OUTPUT_FILE" <<EOF
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="SOMA Markdown Extension">
  <title>$TITLE</title>
  <style>
$CSS_CONTENT
  </style>
</head>
<body>

$CONTENT

</body>
</html>
EOF
else
    # Document with linked CSS
    cat > "$OUTPUT_FILE" <<EOF
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="SOMA Markdown Extension">
  <title>$TITLE</title>
  <link rel="stylesheet" href="$CSS_PATH">
</head>
<body>

$CONTENT

</body>
</html>
EOF
fi

if [ "$INLINE_CSS" = true ]; then
    success "Created standalone HTML: $OUTPUT_FILE"
else
    success "Created styled HTML: $OUTPUT_FILE"
fi

# Calculate file sizes
INPUT_SIZE=$(wc -c < "$INPUT_FILE" | tr -d ' ')
OUTPUT_SIZE=$(wc -c < "$OUTPUT_FILE" | tr -d ' ')

echo ""
echo "File sizes:"
echo "  Input:  $INPUT_SIZE bytes"
echo "  Output: $OUTPUT_SIZE bytes"
echo ""
echo "Open in browser:"
echo "  file://$OUTPUT_DIR/$OUTPUT_FILE"
