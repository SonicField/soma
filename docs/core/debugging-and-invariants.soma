(python) >use (markdown) >use
>md.start

(# 12. Debugging and Invariants) >md.h1

(Debugging tools and assertion mechanisms for verifying program invariants.) >md.p

>md.hr

(## Philosophy: Falsifiability and Invariant Testing) >md.h2

(A claim without a potential falsifier is not useful.) >md.b ( This principle underlies all debugging in SOMA. An assertion that cannot fail provides no information; a test that cannot detect a bug catches no bugs.) >md.t >md.p

(Debugging is not merely finding errors—it is constructing a falsifiable model of program behaviour. Each assertion, each ) (>debug.al.dump) >md.c (, each ) (>print) >md.c ( is a probe that tests a hypothesis about state. If the hypothesis cannot be falsified, the probe is worthless.) >md.t >md.p

(Assertions and tests "colour in" the state manifold where invariants hold.) >md.b ( This is not proof in the general case, but it builds confidence that further invariants can be layered on top. Rigour compounds; so does sloppiness.) >md.t >md.p

(The invariant-testing approach:) >md.p

(State the invariant explicitly) >md.uli
(Write code that asserts the invariant) >md.uli
(Attempt to break it with adversarial inputs) >md.uli
(If it survives, layer additional invariants on top) >md.uli
>md.ul

(A test which is not falsifiable is not useful. This principle extends beyond code to reasoning, documents, and all collaborative work.) >md.p

>md.hr

(## Implementation-Specific Debug Tools) >md.h2

(WARNING:) >md.b ( The ) (debug.*) >md.c ( namespace is ) (implementation-specific) >md.b (, not part of SOMA's core semantics. These tools exist solely for debugging and instrumentation. They must ) (NEVER) >md.b ( be used for normal program control flow or logic. Different SOMA implementations may provide different debug facilities or none at all.) >md.t >md.p

(### >debug.al.dump) >md.h3

(Signature:) >md.b ( ) ((\29\ -> (\29\) >md.c >md.t >md.p

(Displays the current AL and Store state for debugging. Does not modify AL or Store. This is a non-destructive snapshot of machine state.) >md.p

(Example:) >md.b >md.p

(1 2 3
>debug.al.dump   ; Shows AL: [1, 2, 3] and Store contents
>+               ; Compute 2 + 3
>debug.al.dump   ; Shows AL: [1, 5] - verify operation) (soma) >md.code

(Use cases:) >md.b >md.p

(Understanding complex AL manipulations) >md.uli
(Verifying Store state after assignments) >md.uli
(Debugging unexpected stack depth issues) >md.uli
>md.ul

(Errors:) >md.b ( None.) >md.t >md.p

>md.hr

(### >debug.type) >md.h3

(Signature:) >md.b ( ) ((Value\29\ -> Str) >md.c >md.t >md.p

(Pops a value and pushes a string representing its type. Essential for runtime type checking and debugging type-related issues.) >md.p

(Example:) >md.b >md.p

(42 >debug.type        ; AL: ["Int"]
(hello\29\ >debug.type   ; AL: ["Str"]
True >debug.type      ; AL: ["Bool"]
{ >noop } >debug.type ; AL: ["Block"]) (soma) >md.code

(Use cases:) >md.b >md.p

(Runtime type assertions) >md.uli
(Debugging unexpected value types) >md.uli
(Polymorphic dispatch based on type) >md.uli
>md.ul

(Errors:) >md.b ( Fatal if AL is empty.) >md.t >md.p

>md.hr

(### >debug.id) >md.h3

(Signature:) >md.b ( ) ((Value\29\ -> Int) >md.c >md.t >md.p

(Pops any value and pushes an integer identity value. For CellRefs, returns the identity of the underlying Cell. Useful for distinguishing between different instances of mutable structures.) >md.p

(Example:) >md.b >md.p

(a.b. >debug.id        ; AL: [<identity integer>]
thing. >debug.id      ; AL: [<identity integer>]

; Comparing identities
cell1. >debug.id
cell2. >debug.id
>==             ; AL: [True] if same cell, [False] otherwise) (soma) >md.code

(Use cases:) >md.b >md.p

(Verifying that two references point to the same cell) >md.uli
(Debugging aliasing issues) >md.uli
(Tracking object identity through transformations) >md.uli
>md.ul

(Errors:) >md.b ( Fatal if AL is empty.) >md.t >md.p

>md.hr

(## Stdlib Debug Tools) >md.h2

(The standard library provides higher-level debugging facilities built atop the builtins.) >md.p

(### >debug.assert) >md.h3

(Signature:) >md.b ( ) ((Block, Str\29\ -> (\29\ | HALT) >md.c >md.t >md.p

(Executes a condition block; if the result is ) (False) >md.c (, halts execution with the provided error message. If ) (True) >md.c (, execution continues normally with the condition result consumed.) >md.t >md.p

(This is the primary invariant-testing mechanism in SOMA. Use it to assert conditions that must hold for correct program execution.) >md.p

(Usage:) >md.b >md.p

({ x 0 >> } (x must be positive\29\ >debug.assert
{ count limit >< } (count must not exceed limit\29\ >debug.assert
{ name >debug.type "Str" >== } (name must be a string\29\ >debug.assert) (soma) >md.code

(Definition:) >md.b >md.p

({
  !_.msg !_.cond
  _.                                   \29\ Push context for choose branches
  >_.cond                              \29\ Execute condition block
  {
    !_.                                \29\ Pop context (True branch - discard\29\
  }
  {
    !_.                                \29\ Pop context
    _.msg >debug.error                 \29\ Halt with error message
  }
  >choose >^
} !debug.assert) (soma) >md.code

(How it works:) >md.b >md.p

(Stores the message and condition block in the register) >md.uli
(Pushes the register context for later access) >md.uli
(Executes the condition block, leaving a boolean on the AL) >md.uli
(Uses ) (>choose) >md.c ( to select between continuation (True\29\ and error (False\29\) >md.uli
(On False, calls ) (>debug.error) >md.c ( which halts execution with the stored message) >md.uli
>md.ul

>md.hr

(## Debugging Patterns) >md.h2

(Effective debugging in SOMA requires understanding the stack-based model. The following patterns address common debugging scenarios.) >md.p

(### AL Inspection Techniques) >md.h3

(Strategic use of ) (>debug.al.dump) >md.c ( reveals AL state at key points:) >md.t >md.p

(\29\ Pattern: Bracketed inspection
\29\ Wrap complex operations to see before/after state
(Before operation:\29\ >print >debug.al.dump
\29\ ... complex AL manipulation ...
(After operation:\29\ >print >debug.al.dump

\29\ Pattern: Tagged checkpoints
(Checkpoint A\29\ >print >debug.al.dump
\29\ ... code section A ...
(Checkpoint B\29\ >print >debug.al.dump
\29\ ... code section B ...

\29\ Pattern: Value tagging
\29\ Print with context without consuming the value
>dup (Current value: \29\ >swap >toString >cat >print) (soma) >md.code

(### Incremental Testing Approach) >md.h3

(Build confidence through layered assertions:) >md.p

(\29\ Level 1: Input validation
{ input >debug.type "Int" >== } (input must be integer\29\ >debug.assert
{ input 0 >> } (input must be positive\29\ >debug.assert

\29\ Level 2: Intermediate state
\29\ ... computation ...
{ partial-result limit >< } (intermediate value in range\29\ >debug.assert

\29\ Level 3: Output validation
\29\ ... more computation ...
{ result expected-type >debug.type >== } (result type correct\29\ >debug.assert
{ result minimum >> } (result above minimum\29\ >debug.assert) (soma) >md.code

(This layered approach:) >md.p

(Catches errors early, close to their source) >md.uli
(Documents assumptions explicitly) >md.uli
(Provides clear error messages when invariants fail) >md.uli
(Builds a falsifiable model of correct behaviour) >md.uli
>md.ul

(### Writing Testable SOMA Code) >md.h3

(Design for testability:) >md.p

(Isolate pure computations) >md.b ( - Blocks that only manipulate the AL are easy to test. Push inputs, execute, verify outputs.) >md.t >md.uli
(Use assertions as documentation) >md.b ( - Assertions serve dual purpose: runtime checks and specification of expected behaviour.) >md.t >md.uli
(Make state explicit) >md.b ( - Store state in named locations rather than relying on AL depth. Named state is easier to inspect and verify.) >md.t >md.uli
(Test boundary conditions) >md.b ( - Zero, negative, maximum values. Empty strings, single characters. These are where bugs hide.) >md.t >md.uli
>md.ul

>md.hr

(## Reference Table) >md.h2

(Debug operation) (Location) (AL transformation) (Purpose)
>md.table.header
(>print) >md.c (Builtin) ((Value\29\ -> (\29\) >md.c (Output value to stdout)
>md.table.row
(>debug.al.dump) >md.c (Builtin) ((\29\ -> (\29\) >md.c (Display machine state)
>md.table.row
(>debug.type) >md.c (Builtin) ((Value\29\ -> Str) >md.c (Get type name as string)
>md.table.row
(>debug.id) >md.c (Builtin) ((Value\29\ -> Int) >md.c (Get identity of value)
>md.table.row
(>debug.assert) >md.c (Stdlib) ((Block, Str\29\ -> (\29\|HALT) >md.c (Assert condition or halt)
>md.table.row
(>debug.error) >md.c (Builtin) ((Str\29\ -> HALT) >md.c (Halt with error message)
>md.table.row
>md.table

>md.hr

(## Summary) >md.h2

(Debugging in SOMA is an exercise in constructing falsifiable hypotheses about program state. The tools provided—) (>print) >md.c (, ) (>debug.al.dump) >md.c (, ) (>debug.type) >md.c (, ) (>debug.id) >md.c (, ) (>debug.assert) >md.c (, and ) (>debug.error) >md.c (—are probes for testing these hypotheses.) >md.t >md.p

(Make invariants explicit through assertions) >md.uli
(Observe AL and Store state at critical points) >md.uli
(Verify types when crossing abstraction boundaries) >md.uli
(Halt execution when unrecoverable errors occur) >md.uli
>md.ul

(Remember: a test which is not falsifiable is not useful. Every assertion should be capable of failing, and every debugging probe should tell you something you did not already know with certainty.) >md.p

>md.print
