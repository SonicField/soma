(python) >use (markdown) >use
>md.start

) section_00.md
(Control Flow: The Emergent Macro System) >md.h1

(Status) (Normative) >md.dli
(Version) (SOMA v1.0) >md.dli
(Section) (05) >md.dli
>md.dul

>md.hr

) section_01.md
(Overview) >md.h2

(SOMA takes a radical approach to control flow. Unlike traditional languages that provide built-in keywords like ) (if) >md.c (, ) (while) >md.c (, ) (for) >md.c (, or ) (switch) >md.c (, SOMA defines ) (only two control primitives) >md.b (:) >md.t >md.p

(>choose) >md.c (Select between two blocks based on a boolean) >md.dli
(>chain) >md.c (Execute blocks until no block remains on the AL) >md.dli
>md.dul

(From these two primitives, something remarkable emerges: control structures that look and behave exactly like built-in language features, but are actually ) (user-defined patterns) >md.b (. This is SOMA's emergent macro system — a mechanism similar to Lisp's ) (defmacro) >md.c (, but arising naturally from the language's semantics without requiring a separate macro facility.) >md.t >md.p

(This section demonstrates how ) (if) >md.c (, ) (ifelse) >md.c (, ) (while) >md.c (, ) (do) >md.c (, and finite state machines all emerge from ) (>choose) >md.c ( and ) (>chain) >md.c (. Understanding this mechanism is key to grasping SOMA's power as a language that reveals rather than obscures computation.) >md.t >md.p

>md.hr

) section_02.md
(1. The Two Primitives) >md.h2

) section_03.md
(1.1 ) (>choose) >md.c ( — Conditional Selection) >md.t >md.h3

(>choose) >md.c ( is SOMA's only branching primitive. ) (CRITICAL:\29\) >md.b ( It is a ) (SELECTOR) >md.b (, not an executor.) >md.t >md.p

(AL Contract (pre-execution\29\:\29\) >md.b >md.p

(Top → C (false branch value\29\
      B (true branch value\29\
      A (boolean condition\29\) Nil >md.code

(Program syntax:\29\) >md.b >md.p

(A B C >choose) (soma) >md.code

(Semantics:\29\) >md.b >md.p

(Pop three values from the AL: ) (C) >md.c (, ) (B) >md.c (, ) (A) >md.c ( (in that order\29\) >md.t >md.oli
(A) >md.c ( must be a Boolean, or fatal error) >md.oli
(If ) (A == True) >md.c (:\29\ ) (push value ) >md.b (B) >md.c ( onto AL) >md.b >md.t >md.oli
(If ) (A == False) >md.c (:\29\ ) (push value ) >md.b (C) >md.c ( onto AL) >md.b >md.t >md.oli
(>choose) >md.c ( does NOT execute blocks) >md.b ( — it only selects one value) >md.oli
(The unchosen value is discarded) >md.oli
>md.ol

(Example:\29\) >md.b >md.p

(True
  { "Path taken" >print }
  { "Path not taken" >print }
>choose) (soma) >md.code

(Result: AL contains the ) (block) >md.b ( ) ({ "Path taken" >print }) >md.c ( (NOT executed\29\) >md.t >md.p

(To execute the selected block, use ) (>^) >md.c (:\29\) >md.t >md.p

(True
  { "Path taken" >print }
  { "Path not taken" >print }
>choose >^) (soma) >md.code

(Output: ) (Path taken) >md.c >md.t >md.p

(Key distinction:\29\) >md.b ( ) (>choose) >md.c ( is a ) (selector) >md.b ( (picks a value\29\, while ) (>^) >md.c ( is an ) (executor) >md.b ( (runs a block from AL\29\. This separation is fundamental to SOMA's semantics.) >md.t >md.p

>md.hr

) section_04.md
(1.2 ) (>chain) >md.c ( — Block Continuation Loop) >md.t >md.h3

(>chain) >md.c ( is SOMA's only looping primitive. It repeatedly executes blocks until the AL top is no longer a block.) >md.t >md.p

(Semantics:) >md.b >md.p

(Pop the top value from the AL) >md.oli
(If it is ) (not) >md.b ( a Block: push it back and stop () >md.oli (>chain) >md.c ( terminates\29\) >md.oli
(If it ) (is) >md.b ( a Block: execute it) >md.oli
(After execution, examine the new AL top) >md.oli
(If the new top is a Block, repeat from step 3) >md.oli
(Otherwise, stop) >md.oli
>md.ol

(Key insight:) >md.b ( ) (>chain) >md.c ( does not recurse and does not grow a call stack. It is a ) (flat iteration) >md.b ( over a sequence of blocks left on the AL by each previous block.) >md.t >md.p

(Example 1: Single block execution) >md.b >md.p

({ 5 5 >* } >chain) (soma) >md.code

(Result: AL contains ) ([25]) >md.c (. The block executes once, leaves ) (25) >md.c ( on the AL, and ) (>chain) >md.c ( terminates because ) (25) >md.c ( is not a block.) >md.t >md.p

(Note:) >md.b ( For single execution, ) (>{ 5 5 >* }) >md.c ( is simpler (see section 1.3\29\. This example demonstrates ) (>chain) >md.c ('s termination behaviour.) >md.t >md.p

(Example 2: Self-perpetuating block) >md.b >md.p

({ "tick" >print >block } >chain) (soma) >md.code

(This prints ) (tick) >md.c ( forever. Why?) >md.t >md.p

(The block executes, prints ) (tick) >md.c (, then pushes ) (>block) >md.c ( (the currently executing block\29\ onto the AL) >md.t >md.uli
(>chain) >md.c ( sees a block on top and executes it again) >md.uli
(This repeats infinitely) >md.uli
>md.ul

(IMPORTANT ERRATA CORRECTION:) >md.b >md.p

(The original specification contained examples that incorrectly used ) (CellRefs) >md.b ( (trailing-dot paths\29\ with ) (>chain) >md.c (. For example:) >md.t >md.p

(7 square. >chain >print  ; WRONG!) (soma) >md.code

(Under SOMA semantics:) >md.p

(square.) >md.c ( resolves to a ) (CellRef) >md.b ( (not the block itself\29\) >md.t >md.uli
(>chain) >md.c ( sees a non-Block value and immediately terminates) >md.uli
(This is a silent logic error) >md.uli
>md.ul

(Correct form:) >md.b >md.p

(7 square >chain >print  ; CORRECT) (soma) >md.code

(This retrieves the ) (block value) >md.b ( stored at ) (square) >md.c (, not a reference to the cell. All examples in this document use the corrected form.) >md.t >md.p

>md.hr

(1.3 Direct Block Execution: ) (>{...}) >md.c >md.t >md.h3

(The simplest form of control flow is direct block execution. The ) (>) >md.c ( prefix executes what follows — including inline blocks.) >md.t >md.p

(Pushing vs Executing:) >md.b >md.p

({ 5 5 >* }           \29\ Pushes block onto AL (not executed\29\
>{ 5 5 >* }          \29\ Executes block immediately, AL = [25]) (soma) >md.code

(The difference is the ) (>) >md.c ( prefix. Without it, the block is a value on the AL. With it, the block runs immediately.) >md.t >md.p

(When to use direct execution:) >md.b >md.p

(Immediate evaluation) (When you want code to run now, not later) >md.dli
(Grouping operations) (When you need a sequence to execute as a unit) >md.dli
(Inline control flow) (When defining a named block would be overkill) >md.dli
>md.dul

(Example:) >md.b >md.p

(10 !x
>{ x 5 >> { (x is large\29\ >print } { } >choose >^ }
x >print) (soma) >md.code

(The block executes immediately, conditionally printing before the final ) (x >print) >md.c (.) >md.t >md.p

(Contrast with ) (>chain) >md.c (:) >md.t >md.b >md.p

(>{ body }) >md.c ( — execute once, immediately) >md.dli
({ body } >chain) >md.c ( — execute and continue while blocks remain on AL) >md.dli
>md.dul

(Use ) (>{...}) >md.c ( for single execution. Use ) (>chain) >md.c ( when you need looping or block continuation.) >md.t >md.p

>md.hr

) section_05.md
(2. The ) (^) >md.c ( Operator: User-Defined Execution) >md.t >md.h2

(This is the KEY to understanding SOMA's macro-like behavior.) >md.b >md.p

) section_06.md
(2.1 The Problem: Executing AL Top) >md.h3

(In languages like Forth and Lisp, there are built-in primitives for executing a value on the stack:) >md.p

(Forth) >md.b (: ) (EXECUTE) >md.c ( — pops the execution token and runs it) >md.t ( ) >md.dli
(Lisp) >md.b (: ) ((funcall fn args)) >md.c ( — calls the function object) >md.t ( ) >md.dli
>md.dul

(These are ) (language primitives) >md.b ( — you can't implement them yourself.) >md.t >md.p

(SOMA has ) (no built-in execute-from-AL operation) >md.b (. But you can define it:) >md.t >md.p

({ !_ >_ } !^        \29\ Create "execute top of AL" operator) (soma) >md.code

(Now ) (>^) >md.c ( behaves exactly like Forth's ) (EXECUTE) >md.c (:\29\) >md.t >md.p

((Cats\29\ print >^     \29\ Prints 'Cats') (soma) >md.code

) section_07.md
(2.2 How ) (^\29\) >md.c ( Works: Step-by-Step Execution Trace) >md.t >md.h3

(Let's trace the execution of ) ((Cats\29\ print >^\29\) >md.c ( in detail:\29\) >md.t >md.p

(Initial state:\29\) >md.b >md.p

(AL: []) Nil >md.code

(Step 1: ) ((Cats)) >md.c ( — Push string onto AL) >md.t >md.b >md.p

(AL: ["Cats"]) Nil >md.code

(Step 2: ) (print) >md.c ( — Push print block onto AL) >md.t >md.b >md.p

(AL: ["Cats", print_block]) Nil >md.code

(Note: ) (print) >md.c ( without ) (>) >md.c ( pushes the ) (block value) >md.b ( at Store path "print" onto the AL.) >md.t >md.p

(Step 3: ) (>^) >md.c ( — Execute the block stored at Store path "^"\29\) >md.t >md.b >md.p

(The block stored at ) (^\29\) >md.c ( is: ) ({ !_ >_ }) >md.c >md.t >md.p

(When this block executes:\29\) >md.p

(3a. Block starts with fresh Register) >md.b >md.p

(AL: ["Cats", print_block]
Register: {}) Nil >md.code

(3b. ) (!_) >md.c ( — Pop AL top, store at Register root) >md.t >md.b >md.p

(AL: ["Cats"]
Register: {_: print_block}) Nil >md.code

(The ) (!_) >md.c ( operation pops ) (print_block) >md.c ( from the AL and stores it at the Register root path ) (_) >md.c (.) >md.t >md.p

(3c. ) (>_) >md.c ( — Read Register root and execute it) >md.t >md.b >md.p

(AL: ["Cats"]
Register: {_: print_block}) Nil >md.code

(The ) (>_) >md.c ( operation reads the value at Register path ) (_) >md.c ( (which is ) (print_block) >md.c (\29\ and ) (executes) >md.b ( it.) >md.t >md.p

(3d. ) (print_block) >md.c ( executes — Pops "Cats" and prints it) >md.t >md.b >md.p

(AL: []
Output: Cats) Nil >md.code

(Final state:\29\) >md.b >md.p

(AL: []
Output: Cats) Nil >md.code

) section_08.md
(2.3 Why This Is Powerful) >md.h3

(The ) (^) >md.c ( operator is ) (user-defined) >md.b ( using only SOMA primitives:) >md.t >md.p

(!_) >md.c ( (store at Register root\29\) >md.t >md.uli
(>_) >md.c ( (execute from Register root\29\) >md.t >md.uli
>md.ul

(This demonstrates that ) (execution itself is not a primitive) >md.b ( in SOMA — it's emergent from the ) (>path) >md.c ( semantics.) >md.t >md.p

) section_09.md
(2.4 Comparison to Other Languages) >md.h3

(Language) (Execute Operator) (Implementation)
>md.table.header
(Forth) >md.b (EXECUTE) >md.c (Built-in primitive)
>md.table.row
(Lisp) >md.b (funcall) >md.c (, ) (apply) >md.c >md.t (Built-in primitive)
>md.table.row
(SOMA) >md.b ({ !_ >_ } !^) >md.c (User-defined!) >md.b
>md.table.row
>md.table

(This is exactly like Forth's ) (EXECUTE) >md.c ( or Lisp's ) (FUNCALL) >md.c (, but ) (you defined it yourself) >md.b ( using only paths and blocks.) >md.t >md.p

) section_10.md
(2.5 Examples Using ) (^) >md.c >md.t >md.h3

(Execute different operations based on data:) >md.b >md.p

((Hello\29\ print >^        \29\ Prints: Hello
42 inc >^               \29\ Increments: AL = [43]
5 { 10 >+ } >^          \29\ Adds 10: AL = [15]) (soma) >md.code

(Store operations in variables:) >md.b >md.p

(print !_.operation
(World\29\ _.operation >^  \29\ Prints: World) (soma) >md.code

(Build execution tables (see Section 5\29\:) >md.b >md.p

(print !commands.show
inc !commands.next
(show\29\ commands >^      \29\ Executes 'print') (soma) >md.code

>md.hr

) section_11.md
(3. Building Emergent Control Structures) >md.h2

(The power of ) (>choose) >md.c ( and ) (>chain) >md.c ( lies not in what they do individually, but in ) (what emerges when you combine them) >md.b (. Let's build traditional control structures from scratch.) >md.t >md.p

) section_12.md
(3.1 IF (Single Branch\29\) >md.h3

(Traditional syntax:) >md.b >md.p

(if (condition\29\ {
  body
}) Nil >md.code

(SOMA pattern:) >md.b >md.p

(condition
  { body }
  { }
>choose >^) (soma) >md.code

(How it works:) >md.b >md.p

(>choose) >md.c ( selects the body block if ) (True) >md.c (, or empty block if ) (False) >md.c >md.t >md.uli
(>^) >md.c ( executes the selected block) >md.uli
(This is ) (if without else) >md.b >md.t >md.uli
>md.ul

(Example:) >md.b >md.p

(x 10 >>
  { "x is greater than 10" >print }
  { }
>choose >^) (soma) >md.code

(Note:) >md.b ( Without ) (>^) >md.c (, the selected block would just sit on the AL without executing. The ) (>^) >md.c ( operator is what actually runs it.) >md.t >md.p

>md.hr

) section_13.md
(3.2 IF/ELSE (Two Branches\29\) >md.h3

(Traditional syntax:) >md.b >md.p

(if (condition\29\ {
  true_body
} else {
  false_body
}) Nil >md.code

(SOMA pattern (using ) (>ifelse) >md.c ( from stdlib\29\:) >md.t >md.b >md.p

(condition
  { true_body }
  { false_body }
>ifelse) (soma) >md.code

(How it works:) >md.b >md.p

(>ifelse) >md.c ( is defined in stdlib as ) ({ >choose >^ }) >md.c >md.t >md.uli
(It combines selection () (>choose) >md.c (\29\ and execution () (>^) >md.c (\29\) >md.t >md.uli
(One branch always executes) >md.uli
>md.ul

(Raw pattern (without stdlib\29\:) >md.b >md.p

(condition
  { true_body }
  { false_body }
>choose >^) (soma) >md.code

(Example:) >md.b >md.p

(user.authenticated
  { dashboard_page >render }
  { login_page >render }
>ifelse) (soma) >md.code

(Key insight:) >md.b ( The ) (>ifelse) >md.c ( helper demonstrates SOMA's macro-like behavior — it looks like a built-in control structure but is actually just ) ({ >choose >^ }) >md.c ( defined in user code.) >md.t >md.p

>md.hr

) section_14.md
(3.3 WHILE Loop) >md.h3

(Traditional syntax:) >md.b >md.p

(while (condition\29\ {
  body
}) Nil >md.code

(SOMA pattern (using Store for loop variable\29\:) >md.b >md.p

({
  condition
  {
    body
    >block
  }
  { }
  >choose >^
} >chain) (soma) >md.code

(How it works:) >md.b >md.p

(Let's trace execution step by step:) >md.p

(The outer block is pushed onto the AL) >md.oli
(>chain) >md.c ( pops and executes it) >md.oli
(Inside the block:) >md.oli
>md.nest
(condition) >md.c ( is evaluated (pushes a boolean\29\) >md.uli
(Two blocks are pushed (true branch and false branch\29\) >md.uli
(>choose) >md.c ( selects one block based on condition) >md.uli
(>^) >md.c ( executes the selected block) >md.uli
>md.ul
(If ) (condition) >md.c ( is ) (True) >md.c (:) >md.t >md.oli
>md.nest
(The true branch executes) >md.uli
(body) >md.c ( runs) >md.uli
(>block) >md.c ( pushes the outer block back onto the AL) >md.uli
(Block ends) >md.uli
(>chain) >md.c ( sees a block on top and repeats) >md.uli
>md.ul
(If ) (condition) >md.c ( is ) (False) >md.c (:) >md.t >md.oli
>md.nest
(The false branch (empty ) ({}) >md.c (\29\ executes) >md.t >md.uli
(Nothing is left on the AL) >md.uli
(Block ends) >md.uli
(>chain) >md.c ( sees no block and terminates) >md.uli
>md.ul
>md.ol

(Complete example: Count to 5) >md.b >md.p

(0 !counter

{
  counter 5 ><
  {
    counter >print
    counter 1 >+ !counter
    >block
  }
  { }
  >choose >^
} >chain) (soma) >md.code

(Output:) >md.p

(0
1
2
3
4) Nil >md.code

(CRITICAL: Why ) (>^) >md.c ( is needed:) >md.t >md.b >md.p

(>choose) >md.c ( only ) (selects) >md.b ( which block to use (true branch or false branch\29\) >md.t >md.uli
(It doesn't ) (execute) >md.b ( the selected block) >md.t >md.uli
(>^) >md.c ( pops the selected block from AL and executes it) >md.uli
(Without ) (>^) >md.c (, the block would just sit on the AL and ) (>chain) >md.c ( would try to execute it, but the pattern wouldn't work correctly) >md.t >md.uli
>md.ul

(Note:) >md.b ( This example uses ) (counter) >md.c ( (Store path\29\ rather than ) (_.counter) >md.c ( (Register path\29\ because nested block executions have ) (isolated Registers) >md.b (. The inner blocks cannot access the outer block's Register. The Store is globally accessible to all blocks.) >md.t >md.p

(This is a ) (while loop) >md.b ( built from ) (>choose) >md.c ( and ) (>chain) >md.c (. No special syntax. No hidden control structures. Just blocks and state.) >md.t >md.p

>md.hr

) section_15.md
(3.4 DO Loop (Body-First Loop\29\) >md.h3

(Traditional syntax:) >md.b >md.p

(do {
  body
} while (condition\29\;) Nil >md.code

(SOMA pattern:) >md.b >md.p

({
  body
  condition
  { >block }
  { }
  >choose >^
} >chain) (soma) >md.code

(How it works:) >md.b >md.p

(The body executes ) (first) >md.b >md.t >md.uli
(Then the condition is checked) >md.uli
(>choose) >md.c ( selects ) (>block) >md.c ( (continue\29\ or ) ({}) >md.c ( (stop\29\) >md.t >md.uli
(>^) >md.c ( executes the selected block) >md.uli
(If true, ) (>block) >md.c ( causes the loop to continue) >md.t >md.uli
(If false, nothing is pushed and the loop terminates) >md.uli
>md.ul

(Example: Read until sentinel) >md.b >md.p

({
  user_input >read !input
  input "quit" >== >not
  { >block }
  { }
  >choose >^
} >chain) (soma) >md.code

(This reads input until the user types "quit". The body (read operation\29\ always executes at least once.) >md.p

(Note:) >md.b ( The ) (input) >md.c ( variable is stored in the Store (not ) (_.input) >md.c (\29\ so that nested block executions can access it.) >md.t >md.p

>md.hr

) section_16.md
(3.5 Infinite Loop) >md.h3

(Traditional syntax:) >md.b >md.p

(while (true\29\ {
  body
}) Nil >md.code

(SOMA pattern:) >md.b >md.p

({ body >block } >chain) (soma) >md.code

(How it works:) >md.b >md.p

(The block always pushes itself onto the AL via ) (>block) >md.c >md.t >md.uli
(>chain) >md.c ( always sees a block and continues forever) >md.uli
>md.ul

(Example: Server loop) >md.b >md.p

({
  connection >accept
  request >handle
  response >send
  >block
} >chain) (soma) >md.code

(This is the simplest possible infinite loop in SOMA. One block. One continuation. No condition needed.) >md.p

>md.hr

(3.6 Tail-Call Optimization with >chain) >md.h3

(Key insight:) >md.b ( ) (>chain) >md.c ( is perfect for tail-call optimization because it repeatedly executes blocks from the AL ) (without growing the call stack) >md.b (. Each iteration is flat — the previous block's execution completes before the next begins.) >md.t >md.p

(Pattern: Accumulator-Based Recursion) >md.h4

(Traditional recursion builds up a call stack. In SOMA, we use an ) (accumulator pattern) >md.b ( with ) (>chain) >md.c ( to achieve the same result with constant stack space.) >md.t >md.p

(Example 1: Factorial with Accumulator) >md.b >md.p

(5 !fact.n
1 !fact.acc

{
  fact.n 0 >=<
    fact.acc                    \29\ Base case: return accumulator
    {                           \29\ Recursive case: update and continue
      fact.n 1 >- !fact.n
      fact.acc fact.n 1 >+ >* !fact.acc
      fact-step                 \29\ Return self for tail-call
    }
  >choose
} !fact-step

fact-step >chain                \29\ AL: [120]) (soma) >md.code

(How it works:) >md.b >md.p

(Initialize ) (fact.n = 5) >md.c (, ) (fact.acc = 1) >md.c >md.oli
(Block checks: is ) (n <= 0) >md.c (?) >md.oli
(If no (5 > 0\29\: update ) (n = 4) >md.c (, ) (acc = 1 * 5 = 5) >md.c (, push ) (fact-step) >md.c ( block) >md.oli
(>choose) >md.c ( selects the recursive block (which contains ) (fact-step) >md.c (\29\) >md.oli
(Block execution completes, leaving ) (fact-step) >md.c ( on AL) >md.oli
(>chain) >md.c ( sees a block and executes it again) >md.oli
(Repeat until ) (n <= 0) >md.c (, then push ) (acc) >md.c ( (120\29\ to AL) >md.oli
(>chain) >md.c ( sees a number (not a block\29\ and stops) >md.oli
>md.ol

(Key differences from traditional recursion:) >md.b >md.p

(No call stack growth — ) (>chain) >md.c ( is a flat loop) >md.uli
(State stored in Store \29\) (fact.n) >md.c (, ) (fact.acc) >md.c (\29\, not in function parameters) >md.uli
(Each iteration completely replaces the previous one) >md.uli
>md.ul

(Example 2: Fibonacci with Tail-Call Optimization) >md.b >md.p

(0 !fib.a
1 !fib.b
7 !fib.count

{
  fib.a >toString >print

  fib.count 1 >=<
    Nil                         \29\ Base: stop (chain terminates\29\
    {                           \29\ Recursive: compute next
      fib.count 1 >- !fib.count
      fib.a fib.b >+ !fib.next
      fib.b !fib.a
      fib.next !fib.b
      fib-step                  \29\ Return self for tail-call
    }
  >choose
} !fib-step

fib-step >chain) (soma) >md.code

(Output:) >md.b >md.p

(0
1
1
2
3
5
8) Nil >md.code

(How it works:) >md.b >md.p

(Print current Fibonacci number () (fib.a) >md.c (\29\) >md.oli
(Check if count has reached 1) >md.oli
(If no: compute next Fibonacci number, update state, push ) (fib-step) >md.c >md.oli
(>choose) >md.c ( selects the block (which ends with ) (fib-step) >md.c (\29\) >md.oli
(Block completes, leaving ) (fib-step) >md.c ( on AL) >md.oli
(>chain) >md.c ( executes it again) >md.oli
(When count reaches 1, ) (>choose) >md.c ( selects ) (Nil) >md.c >md.oli
(>chain) >md.c ( sees non-block value and terminates) >md.oli
>md.ol

(Example 3: Countdown Pattern) >md.b >md.p

(3 !count

{
  count >toString >print
  count 1 >- !count

  count 0 >=<
    { (Liftoff\29\ >print }
    countdown
  >choose >^
} !countdown

countdown >chain) (soma) >md.code

(Output:) >md.b >md.p

(3
2
1
Liftoff) Nil >md.code

(Note the ) (>^) >md.c ( usage:) >md.b >md.p

(When count reaches 0, ) (>choose) >md.c ( selects the liftoff block) >md.uli
(>^) >md.c ( ) (executes) >md.b ( it (prints "Liftoff"\29\) >md.uli
(Result is nothing on AL, so ) (>chain) >md.c ( stops) >md.uli
(When count > 0, ) (>choose) >md.c ( selects ) (countdown) >md.c ( (the block value\29\) >md.uli
(>^) >md.c ( ) (executes) >md.b ( it, which runs the whole countdown block again) >md.uli
(The recursive call is a tail-call because it's the last thing executed) >md.uli
>md.ul

(Tail-Call Pattern Summary) >md.h4

(General pattern:) >md.b >md.p

({
  \29\ Do work
  work_step

  \29\ Check condition
  done_condition
    final_result          \29\ Base case: value to return
    {                     \29\ Recursive case:
      \29\ Update state
      state_update
      self_block_name     \29\ Tail-call: return self
    }
  >choose
} !self_block_name

self_block_name >chain) (soma) >md.code

(When to use:) >md.b >md.p

(Recursion that would normally build deep call stacks)
(Loops with complex state transitions)
(State machines (see next section\29\)
(Any algorithm that can be expressed as "do work, then decide whether to continue")
>md.ul

(Benefits:) >md.b >md.p

(Constant stack space (no stack overflow\29\)
(Clear state evolution (all state in Store\29\)
(Natural expression of recursive algorithms)
(Same performance as iterative loops)
>md.ul

>md.hr

(3.7 Internationalization: Aliasing >block) >md.h3

(One of the key advantages of ) (>block) >md.c ( over the deprecated ) (_.self) >md.c ( magic binding is that ) (>block can be aliased) >md.b (. This enables fully international code where programmers can use their native language for all built-ins.) >md.t >md.p

(Example: German programmer) >md.b >md.p

(\29\ Alias built-ins to German
Chain !Kette
block !Block

\29\ Infinite loop in pure German
{ "tick" >print >block } >Kette) (soma) >md.code

(Example: Swedish programmer) >md.b >md.p

(\29\ Alias built-ins to Swedish
Chain !Kedja
block !blockera

\29\ Infinite loop in pure Swedish
{ "tick" >print >blockera } >Kedja) (soma) >md.code

(Why this matters:) >md.b >md.p

(The old ) (_.self) >md.c ( approach was English-centric and couldn't be aliased:) >md.p

(\29\ OLD WAY - forced to use English "self"
Chain !Kette
{ "tick" >print _.self } >Kette    \29\ Must use English word "self") (soma) >md.code

(With ) (>block) >md.c (, ) (every part of the control flow is aliasable) >md.b (:) >md.t >md.p

(\29\ NEW WAY - fully international
Chain !Kette
Choose !Wählen
block !Block
Equal !Gleich

\29\ Pure German control flow
bedingung
  { "wahr" >print >block }
  { "falsch" >print }
>Wählen >^                       \29\ Note: >^ needed to execute selected block) (soma) >md.code

(This demonstrates that SOMA has ) (no English-centric special cases) >md.b (. All built-ins, including block self-reference, can be renamed to match the programmer's language and coding style.) >md.t >md.p

(Important:) >md.b ( Note the ) (>^) >md.c ( at the end — this is needed because ) (>Wählen) >md.c ( (choose\29\ only ) (selects) >md.b ( a block, it doesn't execute it. The ) (>^) >md.c ( executes the selected block.) >md.t >md.p

>md.hr

(4. The Macro-Like Behavior) >md.h2

(4.1 What Makes This "Macro-Like"?) >md.h3

(In Lisp, you can define new control structures using ) (defmacro) >md.c (:) >md.t >md.p

((defmacro while (condition &body body\29\
  `(loop
     (unless ,condition (return\29\\29\
     ,@body\29\\29\) (lisp) >md.code

(After defining this macro, ) (while) >md.c ( looks exactly like a built-in language feature. Users can't tell the difference.) >md.t >md.p

(SOMA achieves the same effect ) (without macros) >md.b (:) >md.t >md.p

({ condition { body >block } { } >choose } !while) (soma) >md.code

(Now you can use ) (while) >md.c ( like this:) >md.t >md.p

({ loop_counter 10 >< } { loop_body } while >chain) (soma) >md.code

(To the user, ) (while) >md.c ( behaves like a built-in control structure. But it's not. It's just a ) (stored block) >md.b (.) >md.t >md.p

(Note:) >md.b ( The condition and body blocks would access shared state via the Store (e.g., ) (loop_counter) >md.c (\29\, not via Register paths, due to Register isolation between blocks.) >md.t >md.p

(4.2 Why This Matters) >md.h3

(In traditional languages:) >md.b >md.p

(Control structures are ) (syntax) >md.b >md.uli
(You cannot define new ones without macros or metaprogramming) >md.uli
(The boundary between "language" and "library" is rigid) >md.uli
>md.ul

(In SOMA:) >md.b >md.p

(Control structures are ) (values) >md.b ( (blocks\29\) >md.uli
(You can define new ones using only ) (>choose) >md.c ( and ) (>chain) >md.c >md.uli
(The boundary between "language" and "library" disappears) >md.uli
>md.ul

(This is ) (emergent abstraction) >md.b (. SOMA doesn't provide ) (if) >md.c ( or ) (while) >md.c ( because it doesn't need to. They emerge naturally from the semantics.) >md.t >md.p

(4.3 Comparison to Lisp's defmacro) >md.h3

(Feature) (Lisp defmacro) (SOMA Blocks)
>md.table.header
(Define new control flow) (✓) (✓)
>md.table.row
(No runtime overhead) (✓) (✓)
>md.table.row
(First-class) (✗ (macros are compile-time\29\) (✓ (blocks are values\29\)
>md.table.row
(Requires special syntax) (✓ (defmacro, backtick\29\) (✗ (just blocks\29\)
>md.table.row
(Can pass as values) (✗) (✓)
>md.table.row
(Hygiene issues) (✓ (gensym, etc.\29\) (✗ (Register isolation\29\)
>md.table.row
>md.table

(SOMA's approach is ) (simpler) >md.b ( and ) (more uniform) >md.b (. There is no distinction between "code" and "data" because blocks are both.) >md.t >md.p

(Note on hygiene:) >md.b ( SOMA avoids variable capture issues because each block execution has its own isolated Register. Nested blocks cannot accidentally access outer block Register paths, eliminating a whole class of hygiene problems.) >md.t >md.p

>md.hr

(5. Errata and Corrections Applied) >md.h2

(5.1 CellRef vs Block Values) >md.h3

(Problem:) >md.b ( Original examples used ) (square.) >md.c ( - CellRef - with ) (>chain) >md.c >md.t >md.p

(Why this fails:) >md.b

(square.) >md.c ( is a ) (CellRef) >md.b ( - a reference to a cell) >md.uli
(>chain) >md.c ( requires a ) (Block value) >md.b >md.uli
(>chain) >md.c ( would immediately terminate) >md.uli
>md.ul

(Correction:) >md.b ( All examples now use ) (square) >md.c ( - payload access - to retrieve the block value.) >md.t >md.p

(5.2 Equality Operator) >md.h3

(Problem:) >md.b ( Original spec was inconsistent ) ((() (>=) >md.c ( vs ) (>==) >md.c ( vs ) (=?) >md.c (\29\) >md.t >md.p

(Correction:) >md.b ( This document uses ) (>==) >md.c ( consistently for equality, ) (><) >md.c ( for less-than, and ) (>>) >md.c ( for greater-than.) >md.t >md.p

(5.3 ) (>block) >md.c ( Built-in) >md.t >md.h3

(This document now uses ) (>block) >md.b ( consistently throughout. The ) (>block) >md.c ( built-in pushes the currently executing block onto the AL. This enables self-referential loops and recursive block patterns.) >md.t >md.p

(Key properties of ) (>block) >md.c (:) >md.t >md.p

(It's a built-in operation - like ) (>choose) >md.c (, ) (>chain) >md.c >md.uli
(Can be aliased to any name - enabling internationalization) >md.uli
(Always returns the currently executing block) >md.uli
(Works at all nesting levels) >md.uli
>md.ul

(All control flow patterns use ) (>block) >md.c ( rather than the deprecated ) (_.self) >md.c ( magic binding.) >md.t >md.p

(5.4 ) (>choose) >md.c ( Semantics — Critical Clarification) >md.t >md.h3

(CRITICAL CHANGE:) >md.b ( The semantics of ) (>choose) >md.c ( documented here differ from some earlier informal descriptions.) >md.t >md.p

(Current correct semantics:) >md.b

(>choose) >md.c ( is a ) (SELECTOR) >md.b ( — it selects one value based on a boolean) >md.uli
(It does ) (NOT) >md.b ( execute blocks) >md.uli
(To execute the selected block, you must use ) (>^) >md.c ( - or store and execute separately) >md.uli
>md.ul

(Pattern:) >md.b ( ) (>choose >^) >md.c ( - select, then execute) >md.t >md.p

(This was clarified based on:) >md.b

(Test files - ) (02_advanced_chain.soma) >md.c (, ) (05_test_docs_stdlib.soma) >md.c >md.oli
(Standard library implementation - ) (>ifelse = { >choose >^ }) >md.c >md.oli
(Working SOMA code that consistently uses ) (>choose >^) >md.c ( for execution) >md.oli
>md.ol

(Why this matters:) >md.b

(Separating selection from execution makes SOMA more compositional) >md.uli
(Blocks are truly first-class — you can select without executing) >md.uli
(The ) (>^) >md.c ( operator demonstrates that execution itself is user-defined) >md.uli
(This enables patterns like storing the selected block before executing it) >md.uli
>md.ul

(All examples in this document have been updated) >md.b ( to use the correct ) (>choose >^) >md.c ( pattern where execution is intended.) >md.t >md.p

>md.hr

(Summary) >md.h2

(SOMA's control flow is ) (emergent) >md.b ( rather than ) (prescribed) >md.b (. By providing only ) (>choose) >md.c ( and ) (>chain) >md.c (, SOMA creates a foundation on which all traditional control structures can be built as ) (user-defined patterns) >md.b (.) >md.t >md.p

(Key Semantic Principles:) >md.b >md.p

(>choose) >md.c (SELECTOR — pops condition and two values, pushes the selected value. Does NOT execute blocks.) >md.dli
(>^) >md.c (EXECUTOR — user-defined as { !_ >_ }, pops a block from AL and executes it.) >md.dli
(>chain) >md.c (LOOPING — repeatedly executes blocks from AL until a non-block value appears. No stack growth.) >md.dli
(>{...}) >md.c (DIRECT EXECUTION — executes an inline block immediately.) >md.dli
>md.dul

(The fundamental execution pattern:) >md.b >md.p

(condition { true_branch } { false_branch } >choose >^) (soma) >md.code

(Control flow in SOMA is not hidden behind syntax. It is ) (explicit state transformation) >md.b ( guided by blocks and boolean values on the AL.) >md.t >md.p

>md.hr

(Next:) >md.b ( ) (Higher-Order Patterns) (./higher-order-patterns.md) >md.l ( — Dispatch tables, finite state machines, higher-order blocks, and building a control flow library.) >md.t >md.p

>md.print