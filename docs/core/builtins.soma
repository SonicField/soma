(python) >use (markdown) >use
>md.start

(# 06. Built-in Words) >md.h1

(Built-ins are just Blocks stored at Store paths.) >md.b ( When you write ) (>print) >md.c (, ) (>dup) >md.c (, or ) (>+) >md.c (, you're not invoking special syntax—you're executing the Block stored at that path in the Store. There is no special "built-in" mechanism in SOMA. The ) (>) >md.c ( prefix means "read the value at this path and execute it," which works identically for built-in operations and user-defined blocks.) >md.t >md.p

(This means built-ins could theoretically be overridden by storing a different Block at paths like ) ("print") >md.c ( or ) ("dup") >md.c ( (though this is not recommended\29\. The execution model is uniform: ) (>name) >md.c ( executes whatever Block is stored at that path, whether it was pre-populated by the runtime or defined by user code.) >md.t >md.p

>md.hr

(## Arithmetic Operations) >md.h2

(Arithmetic built-ins operate on integer values. Arithmetic on non-integer values is a fatal error.) >md.p

(### >+) >md.h3

(Signature:) >md.b ( ) ((Int, Int\29\ -> Int) >md.c >md.t >md.p

(Pops two integers ) ((b, a\29\) >md.c ( from the AL and pushes ) ((a + b\29\) >md.c (.) >md.t >md.p

(Example:) >md.b >md.p

(5 3 >+    ; AL: [8]) (soma) >md.code

(Errors:) >md.b ( Fatal if AL has fewer than 2 values or if either value is not an integer.) >md.t >md.p

>md.hr

(### >-) >md.h3

(Signature:) >md.b ( ) ((Int, Int\29\ -> Int) >md.c >md.t >md.p

(Pops two integers ) ((b, a\29\) >md.c ( from the AL and pushes ) ((a - b\29\) >md.c (.) >md.t >md.p

(Example:) >md.b >md.p

(10 3 >-   ; AL: [7]) (soma) >md.code

(Errors:) >md.b ( Fatal if AL has fewer than 2 values or if either value is not an integer.) >md.t >md.p

>md.hr

(### >*) >md.h3

(Signature:) >md.b ( ) ((Int, Int\29\ -> Int) >md.c >md.t >md.p

(Pops two integers ) ((b, a\29\) >md.c ( from the AL and pushes ) ((a * b\29\) >md.c (.) >md.t >md.p

(Example:) >md.b >md.p

(4 5 >*    ; AL: [20]) (soma) >md.code

(Errors:) >md.b ( Fatal if AL has fewer than 2 values or if either value is not an integer.) >md.t >md.p

>md.hr

(### >/) >md.h3

(Signature:) >md.b ( ) ((Int, Int\29\ -> Int) >md.c >md.t >md.p

(Pops two integers ) ((b, a\29\) >md.c ( from the AL and pushes ) ((a / b\29\) >md.c ( using integer division.) >md.t >md.p

(Example:) >md.b >md.p

(10 3 >/   ; AL: [3]) (soma) >md.code

(Errors:) >md.b ( Fatal if AL has fewer than 2 values, if either value is not an integer, or if ) (b) >md.c ( is zero.) >md.t >md.p

>md.hr

(## Comparison Operations) >md.h2

(Comparison operators pop two values and push a Boolean result. String and integer comparisons are defined. Cross-type comparison is a fatal error.) >md.p

(### >==) >md.h3

(Signature:) >md.b ( ) ((Value, Value\29\ -> Bool) >md.c >md.t >md.p

(Pops two values ) ((b, a\29\) >md.c ( from the AL and pushes ) (True) >md.c ( if ) (a == b) >md.c (, otherwise ) (False) >md.c (.) >md.t >md.p

(Example:) >md.b >md.p

(5 5 >==       ; AL: [True]
"cat" "dog" >==   ; AL: [False]) (soma) >md.code

(Errors:) >md.b ( Fatal if AL has fewer than 2 values or if types are incompatible for comparison.) >md.t >md.p

>md.hr

(### ><) >md.h3

(Signature:) >md.b ( ) ((Value, Value\29\ -> Bool) >md.c >md.t >md.p

(Pops two values ) ((b, a\29\) >md.c ( from the AL and pushes ) (True) >md.c ( if ) (a < b) >md.c (, otherwise ) (False) >md.c (.) >md.t >md.p

(Example:) >md.b >md.p

(3 5 ><        ; AL: [True]
10 2 ><       ; AL: [False]) (soma) >md.code

(Errors:) >md.b ( Fatal if AL has fewer than 2 values or if types are incompatible for comparison.) >md.t >md.p

>md.hr

(### >>) >md.h3

(Signature:) >md.b ( ) ((Value, Value\29\ -> Bool) >md.c >md.t >md.p

(Pops two values ) ((b, a\29\) >md.c ( from the AL and pushes ) (True) >md.c ( if ) (a > b) >md.c (, otherwise ) (False) >md.c (.) >md.t >md.p

(Example:) >md.b >md.p

(10 5 >>       ; AL: [True]
3 7 >>        ; AL: [False]) (soma) >md.code

(Errors:) >md.b ( Fatal if AL has fewer than 2 values or if types are incompatible for comparison.) >md.t >md.p

>md.hr

(## Stack Operations) >md.h2

(Stack operations manipulate the AL structure without performing computation.) >md.p

(### >dup) >md.h3

(Signature:) >md.b ( ) ((Value\29\ -> (Value, Value\29\) >md.c >md.t >md.p

(Duplicates the top value on the AL.) >md.p

(Example:) >md.b >md.p

(7 >dup        ; AL: [7, 7]) (soma) >md.code

(Errors:) >md.b ( Fatal if AL is empty.) >md.t >md.p

>md.hr

(### >drop) >md.h3

(Signature:) >md.b ( ) ((Value\29\ -> (\29\) >md.c >md.t >md.p

(Removes the top value from the AL.) >md.p

(Example:) >md.b >md.p

(1 2 3 >drop   ; AL: [1, 2]) (soma) >md.code

(Errors:) >md.b ( Fatal if AL is empty.) >md.t >md.p

>md.hr

(### >swap) >md.h3

(Signature:) >md.b ( ) ((Value, Value\29\ -> (Value, Value\29\) >md.c >md.t >md.p

(Swaps the top two values on the AL.) >md.p

(Example:) >md.b >md.p

(1 2 >swap     ; AL: [2, 1]) (soma) >md.code

(Errors:) >md.b ( Fatal if AL has fewer than 2 values.) >md.t >md.p

>md.hr

(### >over) >md.h3

(Signature:) >md.b ( ) ((Value, Value\29\ -> (Value, Value, Value\29\) >md.c >md.t >md.p

(Duplicates the second value and pushes it on top.) >md.p

(Example:) >md.b >md.p

(1 2 >over     ; AL: [1, 2, 1]) (soma) >md.code

(Errors:) >md.b ( Fatal if AL has fewer than 2 values.) >md.t >md.p

>md.hr

(Debug Operations) >md.h2

(Debug built-ins are used for development and introspection.) >md.p

(>print) >md.h3

(Signature: ) >md.b ((Value\29\ \2D\\3E\ \28\\29\) >md.c >md.t >md.p

(Pops the top value from the AL and displays it to standard output.) >md.p

(Example:) >md.b >md.p

("Hello" >print   ; Output: Hello
42 >print        ; Output: 42) (soma) >md.code

(Errors:) >md.b ( Fatal if AL is empty.) >md.t >md.p

>md.hr

(>dump) >md.h3

(Signature: ) >md.b (\28\\29\ \2D\\3E\ \28\\29\) >md.c >md.t >md.p

(Displays the current AL and Store state for debugging. Does not modify AL or Store.) >md.p

(Example:) >md.b >md.p

(1 2 3 >dump   ; Displays machine state) (soma) >md.code

(Errors:) >md.b ( None.) >md.t >md.p

>md.hr

(Type and Identity Operations) >md.h2

(These operations provide runtime introspection of values and cells.) >md.p

(>type) >md.h3

(Signature: ) >md.b ((Value\29\ \2D\\3E\ Str) >md.c >md.t >md.p

(Pops a value and pushes a string representing its type.) >md.p

(Example:) >md.b >md.p

(42 >type      ; AL: ["Int"]
"hello" >type ; AL: ["Str"]
True >type    ; AL: ["Bool"]) (soma) >md.code

(Errors:) >md.b ( Fatal if AL is empty.) >md.t >md.p

>md.hr

(>id) >md.h3

(Signature: ) >md.b ((CellRef | Thing\29\ \2D\\3E\ Int) >md.c >md.t >md.p

(Pops a CellRef or Thing and pushes an integer identity value.) >md.p

(Example:) >md.b >md.p

(a.b. >id      ; AL: [<unique identity integer>]) (soma) >md.code

(Errors:) >md.b ( Fatal if AL is empty or top value is neither a CellRef nor a Thing.) >md.t >md.p

>md.hr

(Control Flow Operations) >md.h2

(Control flow in SOMA is explicit and built from minimal primitives. These operations enable conditionals and loops.) >md.p

(>choose) >md.h3

(Signature: ) >md.b ((Bool, Value, Value\29\ \2D\\3E\ Value) >md.c >md.t >md.p

(Pops three values ) ((false_val, true_val, condition)) >md.c ( from the AL and pushes the selected value based on the condition. ) (Does NOT execute the selected value.) >md.b >md.t >md.p

(Behavior:) >md.b >md.p

(If ) (condition) >md.c ( is ) (True) >md.c (, pushes ) (true_val) >md.c >md.uli
(If ) (condition) >md.c ( is ) (False) >md.c (, pushes ) (false_val) >md.c >md.uli
(The selected value is pushed to AL as-is \29\not executed\29\) >md.uli
(To execute the result, use ) (>^) >md.c ( or ) (>chain) >md.c ( after ) (>choose) >md.c >md.uli
>md.ul

(Examples:) >md.b >md.p

(; Select a value
True 10 20 >choose      ; AL: [10]
False 10 20 >choose     ; AL: [20]

; Select and execute a block
5 3 ><
  { (small\29\ >print }
  { (large\29\ >print }
>choose >^              ; Selects { (large\29\ >print }, then executes it

; Common pattern: select block for loop continuation
counter 10 ><
  >block                ; Continue - return current block
  Nil                   ; Stop
>choose                 ; AL: [block] or [Nil]) (soma) >md.code

(Errors:) >md.b ( Fatal if AL has fewer than 3 values or if first value is not a Boolean.) >md.t >md.p

>md.hr

(>chain) >md.h3

(Signature: ) >md.b ((Value\29\ \2D\\3E\ \28\\29\) >md.c >md.t >md.p

(Pops a value from the AL. If it's a Block, executes it and repeats \29\pops again\29\. If it's not a Block, stops.) >md.p

(Behavior:) >md.b >md.p

(Pops top value from AL) >md.uli
(If value is a Block: executes it, then repeats \29\pops from AL again\29\) >md.uli
(If value is NOT a Block: stops execution) >md.uli
(Enables loops, recursion, and state machines) >md.uli
(Perfect for tail-call optimization \29\no stack growth\29\) >md.uli
>md.ul

(Examples:) >md.b >md.p

(; Execute a block once
{ 5 3 >+ } >chain       ; AL: [8]

; Infinite loop \29\block returns itself\29\
{
  (tick\29\ >print
  >block                ; Push self back to AL
} >chain                ; Prints "tick" forever

; Conditional loop \29\using >choose\29\
0 !counter
{
  counter >toString >print
  counter >inc !counter
  counter 10 ><
    >block              ; Continue: push self
    Nil                 ; Stop: push Nil
  >choose
} !loop
loop >chain             ; Prints 0..9, then stops

; State machine
{ (A\29\ >print state-b } !state-a
{ (B\29\ >print state-c } !state-b
{ (C\29\ >print Nil } !state-c
state-a >chain          ; Prints "A", "B", "C", stops) (soma) >md.code

(Errors:) >md.b ( None \29\stops cleanly on non-Block values\29\.) >md.t >md.p

>md.hr

(>block) >md.h3

(Signature: ) >md.b (\28\\29\ \2D\\3E\ Block) >md.c >md.t >md.p

(Pushes the currently executing block onto the AL.) >md.p

(Behavior:) >md.b >md.p

(Always succeeds \29\execution always occurs within a block context\29\) >md.uli
(At top-level: returns the outermost block \29\the implicit "program" block\29\) >md.uli
(In nested blocks: returns the current block \29\not the parent block\29\) >md.uli
(Enables self-reference for loops and recursion) >md.uli
(Can be aliased like any built-in, enabling internationalization) >md.uli
>md.ul

(Examples:) >md.b >md.p

(; Get current block for recursion
0 !counter
{
  counter >toString >print
  counter >inc !counter
  counter 5 ><
    >block              ; Continue: push self
    Nil                 ; Stop
  >choose
} >chain                ; Prints 0..4

; Store reference to current block
{ >block !_.me _.me }   ; Store reference in Register, push to AL

; Internationalization via aliasing
block !блок             ; Russian
block !ブロック          ; Japanese
{ (loop\29\ >print >блок } >chain   ; Use Russian alias) (soma) >md.code

(Errors:) >md.b ( None.) >md.t >md.p

>md.hr

(No-Op) >md.h2

(>noop) >md.h3

(Signature: ) >md.b (\28\\29\ \2D\\3E\ \28\\29\) >md.c >md.t >md.p

(Performs no operation. The AL is unchanged.) >md.p

(Example:) >md.b >md.p

(>noop         ; AL unchanged) (soma) >md.code

(Errors:) >md.b ( None.) >md.t >md.p

>md.hr

(Reference Table) >md.h2

(The following table summarizes all core built-in operations:) >md.p

(Built-in) (Pops) (Pushes) (Action)
>md.table.header
(>dup) >md.c (1) (2) (Duplicate top value)
>md.table.row
(>drop) >md.c (1) (0) (Drop top value)
>md.table.row
(>swap) >md.c (2) (2) (Swap top two values)
>md.table.row
(>over) >md.c (2) (3) (Duplicate 2nd value)
>md.table.row
(>+) >md.c (2) (1) (Integer addition)
>md.table.row
(>-) >md.c (2) (1) (Integer subtraction)
>md.table.row
(>*) >md.c (2) (1) (Integer multiplication)
>md.table.row
(>/) >md.c (2) (1) (Integer division)
>md.table.row
(>==) >md.c (2) (1) (Equality test)
>md.table.row
(><) >md.c (2) (1) (Less-than test)
>md.table.row
(>>) >md.c (2) (1) (Greater-than test)
>md.table.row
(>choose) >md.c (3) (1) (Select value based on condition \29\doesn't execute\29\)
>md.table.row
(>chain) >md.c (1) (0) (Execute blocks repeatedly until non-Block)
>md.table.row
(>block) >md.c (0) (1) (Push current executing block)
>md.table.row
(>print) >md.c (1) (0) (Print value to stdout)
>md.table.row
(>dump) >md.c (0) (0) (Dump machine state)
>md.table.row
(>type) >md.c (1) (1) (Get type name as string)
>md.table.row
(>id) >md.c (1) (1) (Get identity of CellRef/Thing)
>md.table.row
(>noop) >md.c (0) (0) (No operation)
>md.table.row
>md.table

>md.hr

(AL Contracts) >md.h2

(Each built-in has a fixed AL contract:) >md.p

(AL underflow) >md.b (Attempting to pop from an empty AL is a fatal error) >md.dli
(Type mismatch) >md.b (Providing the wrong type to a built-in is a fatal error) >md.dli
(Arity violation) >md.b (Having insufficient values on the AL for an operation is a fatal error) >md.dli
>md.dul

(SOMA does not attempt recovery from violations. Program correctness is the programmer's responsibility.) >md.p

>md.hr

(Notes) >md.h2

(While built-ins could theoretically be overridden \29\they're just Store paths\29\, doing so is strongly discouraged) >md.uli
(All built-in operations are synchronous and deterministic \29\except those involving external I/O\29\) >md.uli
(Built-ins operate directly on the AL and do not access the Store unless explicitly documented) >md.uli
(More specialized built-ins may be defined in extensions \29\e.g., for Things, concurrency, or I/O\29\) >md.uli
>md.ul

>md.print